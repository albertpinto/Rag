 Music It is my pleasure and pride to present our speaker today, Dr. Dilip Krishnaswamy. He is an extraordinarily accomplished researcher and scholar whose inventions have led to over 50 patents. He has authored over 100 articles and research papers and presented at conferences worldwide for the last three decades. He entered IIT Chennai as one of the top rank holders in JEE and went on to finish with academic distinction. Subsequently, he did his doctoral research at the University of Illinois at Urbana-Champaign in computer science. He went on to continue his research at Intel, Qualcomm, IBM, and now finally he is the vice president at Reliance Industries, leading research and innovation. We met when we were young in graduate school years of doctoral studies and it has been a matter of pride to have known him as a lifelong friend. Today, he will now be speaking on quantum computing. Philip? Philip G. Hey, Asif. Thanks for the intro. Yeah, it's been fun in this life knowing Asif and hope I get to know you in future lives as well. But for me Asif has been a wonderful soul. He's been part of my journey. So thank you Asif for being there. And just want to talk about some work that I have started venturing into personally, just out of interest, and thought I would share some of what I've learned. And I'm still learning, and maybe able to answer some of your questions and not others, but I will plead ignorance when I if I don't know so but one of the things that's going on with regard to the work that I'm doing is that we are deploying like future 4G, 5G, 6G kind of networks. And in that, the infrastructure is getting increasingly virtualized. And I just wanted to give you a context of where the research is coming from. The infrastructure is virtualized. Everything is executing as microservices and containers or virtual machines. And you may have like a cloud data center, an in-network data center, an edge data center, things like that, and these microservices executing tasks. It's not just about the network, but it's applications of the services and things like that so then this as you all know there's a trend towards just aggregation with micro services and we've started working on AI ML algorithms and blockchain and so we can think of quantum inspired algorithms as well to execute inside these micro services some recent work has happened where you know somebody was inspired algorithms as well to execute inside these microservices. Some recent work has happened where somebody was trying to create a recommendation engine, but just by designing the algorithm in a slightly different way, as if you're exploring a super position of states as you go along in your search, but executing it on a classical algorithm, classical computer itself, that itself gives different benefits and improvements and the results that come about. So people worry about when quantum computers will be available and things like that, but maybe we don't have to wait. Maybe we can just write our algorithms for Intimense 5, seeing how, you know, business and engineers have tried to build quantum computers and you know, when the computers do have a lot of qubits available, we could also use them. They're already available, but you know they can probably solve smaller dimensional problems right now but we don't have to wait is what i'm saying we can think quantum in in the way we design a little part and see if that leads us somewhere and people are just beginning to do that so So maybe this talk will lead you down that journey. So just getting back into quantum, there's this famous double slit experiment that you would have seen probably in your 12th grade So you'd have seen probably in your 12th grade studying physics and trying to find out what's the distance between the peaks that fall on the screen in the back. But when we studied that in high school, we thought of light, a whole bunch of photons going on a screen which had two slits, and then you would get this interference pattern. So we used to think like these were waves and they were interfering with each other. And so you get these peaks and troughs and all of that. And, but the interesting thing is, the funny thing is, if you slow this down, and just, you know, you're sending 100 photons, maybe slow it down to 50 photons, 10 photons, five photons, finally, bring it down a single photon that you're throwing at the slit, but you send a photon at a time, and then you observe the pattern over time you'll still see this interference pattern which is which sounds crazy isn't it i mean in the sense that a single photon had the knowledge about the probabilities in the system to actually work probabilities in the system to actually work with the future photons actually produces interference pattern. So what's happening is that this single photon exhibits characteristics not only of a particle but also for wave and as you know probabilities associated with where which part it will take to finally end up on the screen and and then when you take a collection of photons you actually get this so so it's neither a wave nor a particle actually but you know it's it's the you define it as if it's a wave function with a certain behavior and and the different paths can it that it can take are all in super position and at some point just before observation it ends up taking one of the paths or at the time of observation. So people have even tried to peek at the other side of the slit to see hey can I see what's happening to the photon but the moment you observe it it's taking you're forcing it to take a decision. So it's really funny, but in quantum realm, the cubit or these quantum particles stay in a superposition of states until you mess with them. And you try to observe them and then they collapse to one of the states. And so you never know what it was, what state the photon was in, or what superposition of states, what probabilities they were in. When you make a measurement, you just get one of the states. And then it's deterministic after that. So this double slit experiment had this interference pattern with this constructive and destructive interference. But, you know, still get it even if it's a single photon. And so each particle is in a superposition of states. And the measurement collapses the state and introduce a few equations but we quickly go in the quantum computing part but some of the properties are the you know like a photon has energy we say H nu or HF right but there's also this reduced Planck's constant that's another way of writing it as h cross Omega and which is H by 2 pi and similarly with the de Broglie equation you're seeing lambda equals H by P but you can write P is h cross k. So, where k is called the wave number, two pi by lambda. So there are two different ways of writing the equations. If you introduce the two pi and you use the reduced Planck's constant. And so typically you use k and you use omega rather than f and lambda. And so typically you use K and you use omega rather than F and lambda. And then the energy, let's say is P square by two M for a quantum particle. The phase velocity, if you look at, would be omega by K K and then if you just take the energy divided by the momentum this Omega by K you can multiply this h cross and the numerator and denominator and you get e by P but then it looks like it's V by 2 but actually what's happening is it's not just a single particle it's a group it's a packet that's constructed by superposition of waves which has a group velocity which is given by this d Omega by DK when you do that and you still multiply these H's you get de by DP which and then the two cancel cell and you get the speed so that this is actually the particle is moving as a wave packet you know as a combination of as a superposition and this if you if you think of it may have some characteristic lambda or wavelength or this wave number this Omega is typically a function of that you know the frequency you can find the frequency once you know the speed and so but the so the Omega is a function of k where k itself is not discrete, like it's a, can be a continuous function. Think of it like a Gaussian function with a very sharp peak. And, and so, and that's the group of waves, you know, that's actually moving in this case and uh so i'll skip all this but it turns out that um so asif didn't want me to throw you too much of equations from this side but at the end of it it turns out they all obey what are called schrodinger's equations uh this is for a free particle there's another equation and the presence of a field and so on. So, but the interesting thing is that this kind of differential equation is linear in the sense that if you have a side two. You can linearly combine this so that you can have, you can think of linear superposition or rated superposition of these wave functions. So, when we talk about quantum computing, what's really happening is all these physical phenomena happening in the background. And we just abstracted away with this notation. And then we forget that, hey, all of this integrals and differentials and all those things are going on out there. So now, and the thing is, you don't have to really worry about it. I mean, the physicists will take care of all of the physics behind it. What happens is that a whole bunch of different types of operations can be performed on what are called quantum bits and you don't have to worry about how it's getting done inside the quantum computer. It's just like you know when you do digital design and you have man gates or nor gates and things like that you can combine these gates anyway you like to realize some digital function in the quantum realm also you have a whole bunch of functions that can be realized and And all that they do is they, they work on the bits and the operations are matrix operations on those bits. And, you know, when you do some computation, when you go to a sequence of gates, you're just multiplying one matrix after another. So, and the end result is the product of all the matrices You know from right to left the leftmost is the most recent operation that you perform so so now you You know all of you have you available with you a library of gates that you will work with to actually operate on qubits and try to do some fun stuff. So I'll try to explain how a couple of things like quantum search and quantum optimization get done, but just some preliminaries about how you work with these qubits right now. So this wave function, let's say you have you work with these qubits right now. So this wave function, let's say you have, we said, you know, the particle, the state of the particle is not known until you observe it. And when you observe it collapses, it'll collapse to either zero or one. So let's say there's a particle with two states, you know, and describe these two states as 0 and 1. This can be like spin up or spin down and things like that. And there could be a probability associated with each of these states. And now these are the side this notation a vertical sign followed by this wave function followed by the right arrow you know that's the description for the wave function now you write that as a summation of this possible states of intake 0 or 1 and these are called amplitudes what's standing in front of the zero state and the one state the probabilities are the squares of amplitudes and they're real but you actually take the complex conjugate and then multiply that to actually get it. These amplitudes can actually be complex. The notion for complex is basically that there can be a phase associated with a rotation if it is not real. But just that phase is getting captured as a complex representation. So what you have is there are two states, there are probabilities associated with the states such that alpha 1 squared plus alpha 2 squared equals 1. Think of them as real for now and just that what you have here is the square root of the probabilities. So if they were equally likely the probabilities would be half and half so what would alpha 1 and alpha 2 be can anyone tell me what would be the amplitude pardon the amplitude pardon the probabilities are half right alpha one and alpha two alpha one square and alpha two square are the probabilities so alpha one alpha two will be so alpha one square is half alpha two square is half is it 0.707 yeah yeah right one over root two one over root two and you'll see that you know it'll continuously getting used so so don't when you see that don't get scared hey where's this square root of two coming from? And we'll see what this means in just a bit, why there's a square and things like that. It actually relates to energy. So what happens is that typically light as it's traversing, So what happens is that typically light as it's traversing, it's a transverse electromagnetic wave. The direction of the electric field is called the polarization of the photon. Electric field is oscillating in one direction. The magnetic field is oscillating in a perpendicular direction, and the wave is propagating perpendicular to both of them, E cross H. So the, and the direction of the electric field is called the polarization. And if it arrives, if a photon arrives at a polarizer, you know, and magnitude is A at a triangle alpha, then A cos alpha is the amplitude that is transmitted through the polarizer and then the thing that's perpendicular to it will be filtered out so the energy of the wave is proportional to the square of the amplitude and hence proportional to cos square alpha so cos square alpha is a fraction of energy that gets transmitted past the polarizer. So think of the probability as relating to energy, right? You have amplitudes, and the probability relates to the energy of the system. So there's a probability cos square alpha for the photons to go through, depending on the polarization and the direction of input. And so what you say is before it hits the polarizer, you know, there's a component say along X that is going to get transmitted, that component has a value cos-alpha, The component Y that's perpendicular, that's going to get filtered out. So it's in a superposition of states with amplitudes cos alpha and sine alpha. Once it gets through the polarizer, it, the state is just, this photon X, right? It's just more, has a component only in this X direction so there's now this amplitude is one there's no more of this y to create so it's at this point so what happened was that this this cos square cos square alpha was effectively how much energy went through. If you put through a whole bunch of photons to the polarizer, the total energy coming out will be cos square alpha of the input energy. So that's where we can start thinking of what these probabilities are that relate to energies in the system. Now, as we said, these quantum particles in a superposition states, but if you try to observe it, the moment you observe it, the state of the particle collapses. It will collapse to either zero or one. But it depends on the probability. So if the probabilities for say state 0 is higher than the probability for state 1 and then there's a possibility that when the collapse happens it'll actually go to state 0 instead of state 1 and vice versa if 1 has a higher probability and that is what is used in say a quantum search algorithm where what you try to do is you try to manipulate with these probabilities such that when you try to collapse you end up with the answer to the problem. Because the answer to the problem has now achieved a higher probability through the manipulation through quantum gates in the system. And we'll see how that is done. There is... So, you know, the moment you observe, you have no... You have completely lost information about the probabilities that that particular quantum particle had. All you know is what state it took. So it's possible that zero was higher probability when you measure you get a one. So you have no knowledge that zero was higher probability when you measure you get a one. So you have no knowledge that zero was indeed a higher probability at that point in time for that particular photon. So, and because of this, there's also this thing called no cloning theorem that is that, you can clone clone a digital bit you can write a copy one a bit with its either one or zero to some other place in memory but a quantum particle cannot be copied because we don't know the probabilities that it has so that's so you have to live with that you have to live with all all the series of sympathies and still try to utilize. This is Avijit. Can we ask question in between or towards the end? Yeah, yeah, go ahead. Please stop. Please ask. Yeah, just one question in the previous slide. You don't have to go back. You said that we don't know anything about us about the states we just know once we observe whatever the state it is that's what we know we so we we manipulate it by transforming so how do you transform if you don't also so I come to that a little later but you use you keep the qubits in the quantum states and actually apply what say if you can do a hard amount gate which is actually trying to entangle cubits which which effectively is implemented by putting it through a polarizer uh being splitted and then output outcomes and entangled set of cubits and which you can work with but the probabilities get carried through in the process and we'll see how that happens very quickly. Okay yeah I think it will appear. Thank you. So the typical convention is 0 is represented as a column basis 1, 0 and 1 is represented by the column basis 0, 1 and then the wave function as a superposition is represented as alpha 1, 1, 0 and alpha 2, 0, 1. So actually just leave it like this rather than this and then if the two states are equal probably like we just discussed it's probably 1 over root 2 and 1 over root 2 two that could be minus one over root two and one over two and they can be on i also uh in this uh out here so um so we can have another quantum particle uh b which can be in a similar in superposition of states but maybe the probabilities are different such that the sum of the probabilities is one. Now when you work with multiple qubits you have to think of the combined state of those qubits. If they're not entangled then all possible all possibilities are available 0 0 0 1 1 0 1 1 and so you do you represent that as a tensor product. Don't get tense about the tensor we'll see exactly what it is just a bit but if you try to you know expand it out you can see that you get alpha 1 beta 1 and then 0 0 alpha 1 beta 2 and zero one alpha two beta one one zero alpha two beta two one one now this looks a little scary but we actually end up write it more simpler and then now it's getting less scary right so zero you write this guy as just zero zero zero one 1 0 but now if you write that so the two particles this is the combined state alpha 1 beta 1 0 0 1 and if you take the squares of all of these things and you add them all up you'll find that some of the probabilities are still 1 can somebody tell me now uh if you have these four states what would be the if they're all equally likely what would be the numbers sitting in front here yeah half yes half because half square is one fourth one fourth plus one fourth plus one fourth plus one fourth. Sajeevan G. So it's a one over square root of twos. We have half two bits of fun. You don't have the square roots anymore. Sajeevan G. Okay, so this is what a tensor product looks like. Okay. All you do is Sajeevan G. you take this column vector and and then this column vector and so this is zero and one but let's see one applied to zero kind of things and then the vectors look different so this zero we said is one zero right so you keep repeatedly applying the bits associated with this column vector on on the other other column vector for zero so this is zero this is zero and then one was zero one right so zeros applied to one zero and one is one applied to one zero and you get a four dimensional column vector which is zero zero one zero and similarly say one one zero one is applied to 0 1 up here and down here and you get 0 0 0 and similarly 0 acting on 0 you get 1 0 0 0 so you get all four possibilities this is like one zero zero zero zero one zero zero zero zero one zero zero zero zero zero one um now what if you had a third qubit can somebody tell me what this column vector would look like if you repeatedly apply what do we have to do you have to take each one of these guys and then let's say you have to apply it to it acts on a one. Then what is the length of the column vector? Each of these entries in this column vector is acting on this two bit column vector. So how long will it be? If you have to apply it to another qubit. Eight? Yeah, eight. Yes. So, and then you can build it. So that's called a three-qubit register. Then you can grow any number of qubits. So, so 0, 0, 1 is like this. And then these are the four possibilities, 0, 0, 2 qubits. There's another notation, it's called the inner product, which is basically the mirror version. This is called a get and this is called a bra. So this inner product is called a bracket operation and it's actually operation and it's actually obtained by using the conjugate transpose and if it's real you just take the transpose and just multiply and so it's like a dot product kind of thing so you just and these were these were our column vectors, right? The kets were our column vectors. So if you did the transpose, this becomes a row vector. So the row vector acts on a column vector and gives you a number. And that's for the inner product. So we will see the usage of this a little later. So there are unitary transformations that you have, like I said, when you do quantum computations, you're applying unitary matrices. So to transform them, and this basically entangles them, helps in entangling. So we'll see how we actually entangle a little later. But so a unitary matrix has a property that if you, you know, apply to itself, you get an identity matrix. So you apply H to itself, you get, say H is this matrix which is trying to you know the first row is just copying over it's not changing but this one is flipping the second component in the column so so what does it do we'll see a geometrical representation of that but you can see that if you multiply this matrix twice, you end up getting the identity. So it's unitary. And when H is applied to zero. So you have this H matrix and you apply it to zero, you get one over square root of two, one, one. So this is like at 45 degrees. Right. And so and this one is 1 minus 1 so this is sort of like it minus 4 so this like to 1 0 getting transformed to this also called this plus state those called a minus state also called a minus state. These are also called Bell states. But geometrically you can see what's going on. One zero is zero right. Let's let's draw zero on say what's the x-axis. It's going rotating to 45 degrees. So I say is it a 45 degree rotation but then look at one. one is let's say up here Pointing towards the y-axis But if you rotate it and have one minus one at one square root of truth actually pointing downwards here to minus 45 so So it's not just a Rotation by 45 degrees. This guy's rotating by 45, but this is 135. And this is anticlockwise. That's clockwise. So is there another way to look at it? You can draw a line at 22 and a half degrees and say, I'm going to reflect at that so you left reflect along pi by 8 and then you know hey this guy goes here that guy goes there so this is one interpretation this is a reflection transform at the angle pi by 8 but there's another way of looking at it which is first rotate clockwise by 45 degrees and then reflect around zero. Sajeevan G. Okay. Sajeevan G. So, oh, by the way, we go back here. We said these matrices are unitary you should get back what you got. So if you define this as rotation around pi by eight, this goes reflection around pi by eight, then this goes here, and if you reflect it back, it just comes back here. So this guy goes here, and then you reflect back, just goes back there, right? So all that's, so you can see that when you apply a second time, you just get back what you started. So let's see if that works here also in this thing what happens is here we give the other interpretation is let's rotate 45 degrees clockwise and then reflect it around C so then it goes yeah this is fine right that's this guy what about 0 1 1 rotate clockwise before Friday because it reaches this here and then you rotate it around so close down here so so yeah you can rotate by clockwise and then reflect what if you reverse the operation if this guy so now if we have this right as the result of applying the matrix once if you rotate clockwise by 45 degrees you end up at zero and then you reflect around zero you stay where you are what about this guy you rotate clockwise by 45 degrees you end up here and then you reflect and then you end up back there so you still both interpretations get you the same answer so So there, but here, what you would say is you would apply a rotation matrix followed by reflection matrix. But this rotation matrix is for pi by four. Whereas the other one would just say reflect with respect to the pi by eight. So effectively all that's happening is these are matrix transformations that are happening and You know and then you apply them in sequence. There are other types of gates. There's an identity design to decade This is a poly matrix. These are poly matrices Asif can tell you a lot about what all of these mean in physics, but relate to spins and all of that stuff. But for us, it's an abstraction that it's just a matrix that you can multiply. But this one you can see just flips the bits. It's also called a not gate. And this is another gate called a C-NOT gate, which flips a target bit if a control bit is a one. So, and it's very useful, extremely useful for entanglements to see what it does. So you have this, let's say four different probabilities, zero, zero, zero, one, one, zero, one, one. Now let's call the first bit a control bit. So if the control bit is a one, then it's going to flip, right? So it's not going to change. If this guy's the control bit, it's not, if it's zero, it's not going to change. So this remains unchanged. This remains unchanged. But here the control bit is a one. So the second bit flips to a one and here it's a one. So the second bit flips to zero so it selectively flips the second bit if the first bit that's an interesting property that the skate has and in general you know you can have K qubits and so two raised to K possible states like you said when you have 3 qubits we have 8 possibilities and so on. Then you have each of those states can be all possibilities and then they can be amplitudes associated with states. And so when you're trying to search for something and you're trying to find something which is highly probable, basically, you're trying to find the one which has the highest amplitude. So this is a single qubit register, right? This is a two qubit register, right? This is a three qubit resistor, right? This is a three qubit resistor, right? And so on, right? So, in order to worry about tensor products anymore, it's all just, it all looks like this. So, now comes a very interesting thing called quantum entanglement, which is a phenomenon where you actually take two photons, but if they could be directly entangled or inversely entangled in the sense, if one, if you make a measurement on one of the entangled photons you can you you can read the state of the other and if you observe the state of the other photon it'll end up if they directly entangled it end up being the same so observation of any one of them collapses the state but it also immediately collapses the state of the other one even if you didn't observe it so you can look so important observe it any point later in time and you'll find that it is what it would have collapsed to. So you entangle them, but you could be mostly entangled as well. So the quantum entangled state would be represented like this. Like if it's directly entangled, if one is zero, the other is a zero. If one is a one, the other is a one. And then you would have one over square root of two. It's coming back to quantum. So these are the Bell states. But it's not decomposable anymore. write it as you know the state for the first qubit tends a product with all possibilities to the second qubit now that you only have 0 0 0 1 as possible so you can't decompose it individually and that's why it's entangled and you could you could have inverse entanglement also, 0, 1, and 1, 0, and so on. And this is possible when you generate particles of opposite spins. And so the entanglement is opposite correlation. So if you observe one and you see a zero, that means the other one is collapsing into one at the same time. And this they have shown happening across distances or 130 kilometers and so on on earth. They've shown it working in space and things like that to ground to earth. But distance is sometimes a problem, I believe, to propagate the light and to actually receive it on the other end. So and then you can have multiple entangled photons as well. So if there are four qubits that entangle directly right like this. But you can have a hybrid combination of this entanglement for multiple qubits. So how do you create an entangled qubit? You apply the Hadamard first. Hadamard is the reflection just talked about. So when you apply the Hadamard, let's say you have this, you have two qubits and you apply the harder model. What's happening, let's say, is you apply it to only one of the qubits. So let's say we apply it to the first qubit. So then the zero is going to expand into the 45 degree direction, right? So it'll be one over root of zero and one over... Now you're fine we can yeah so you apply the this hard mark transformation to one of the cubits and then essentially expanding one of the bits in the 45 degree direction and and you keep doing that but holding the other bit as as it is so when you do that the the one the ones became like mine had the minus one over two and then if these probabilities are all equal the minuses cancel and then you're just left with say this 1 over the zeros combining and the one zeros combining but the 0 1 is canceling with another instance of the zero one if these gamma, gamma one equals gamma two and then gamma four equals gamma three. And so you end up with this kind of a result. But you really when you saw when you wanted entanglement, we wanted this to be a one. So when you do that, to do that you apply the CNOT key. So CNOT key it says, if the control bit is a one, I'm gonna flip. So this is a control bit, and when it is a one, it's gonna flip. So you apply the CNOT to this system, and then you get this. So applying the harder mark followed by the CNOT creates an entangled state. And then that is used a lot in quantum processing. So you apply these kinds of transformations repeatedly and the probabilities get refined during processing and the higher probability state could become more and more likely and provide a good solution. And you can also do hybrid solutions. You can set up the problem for the quantum processor, let it do some stuff, make a measurement, then you can set up a different modified problem for the quantum processor and then keep doing this in an iterative fashion. And there is a famous algorithm called Shor's algorithm for factorization which tries to find the period of a function in the first part classically and then applies what's called a quantum Fourier transform which utilizes the Hardemar gates multiple times followed by additional transformations and to get speed up in the quantum realm so you can look at the wikipedia page for it you'll see a circuit structure very and you'll see a whole bunch of horizontal lines each horizontal line is a qubit and then you can put them through gates and things like that and out comes the final answer so with quantum search um you know you want to work on these qubits but you want to find you want to target the search in a particular direction and the key technique is called amplitude magnification you want to target the search in a particular direction. And the key technique is called amplitude magnification. You want to amplify what could be more important. So I'm applying this currently to, say, wireless networking. And so if I want to give a node that has to transmit more importance, I'll apply this transformation this what's called an Oracle that tries to focus on that particular state that's more important and then we do a reflection so so this algorithm is called Grover's algorithm let's say you have n items and each one has the state X I and we are searching for one of the items, i equals k. So we can create a quantum state, which is superposition of states of all of these n items, and you get this kind of an equation. So initially, all these states are equally likely. And so, you know, when this, the amplitudes will be one over square root of n, right? Because the probabilities are one over n, so the amplitudes will be 1 over square root of n right because the probabilities are 1 over n so the amplitudes 1 over square root of n. So now what you're searching for is inside the wave function with an amplitude of 1 over square root of n. Now what you do is you apply what's called an oracle function such that it changes the sign of the amplitude for this and leaving the other ones unchanged. So all the other states remain with probability one or square root of n, but this particular Asim Kadavig- X k has an amplitude now minus one or square root of n. Then what you do is you reflect with respect to the side. And this results in an enhanced amplitude for xk. And then you keep doing this again and again, you start improving the probabilities for this while the other probabilities reduce. And we'll see exactly why that happens. First, let's understand what's reflection. Reflection is defined as this equation. And let's see what happens if you, psi is one zero and you try to apply it to itself. So when you do this, this is the ket, this is the bra when you apply it, this is the ket, and this is the bra. When you apply it one next to the other, you get 1, 0, 0, 0, right? And you do twice that minus i, so twice this matrix minus the identity matrix, and you get 1, 0, 0, minus 1. So you apply this, let's say, on 1, 0, and you'll still get 1, 0, because 0, minus 1 acting on 1, 0 will give you a 0. And 1, 0 acting on a 1, 0 gives you a 1, 0. So under this reflection, based on this psi, 1, 0 remains unchanged. But if you apply to 0, 1, then 0, 1 reflects and becomes 0 minus 1 so if 0 1 was pointing in the positive y direction now it'll point to the negative y direction but if this guy 1 0 is pointing in the positive x direction it remains so you can see that uh you know the reflection transform you know, the reflection transform. When you say reflection by psi, with respect to psi, if you apply it to psi, it shouldn't change, right? Like when you saw earlier, we were reflecting along the, with respect to the X axis, and if you're already on the X axis, you don't shift. So that's what's happening. You can see if you change psi to zero one, the same thing happens. When you do the psi, you end up getting minus one, zero. So when you apply minus one, zero to zero, one, to minus one, zero to one, zero, you get a minus one, zero. But when you apply to a zero, one, it remains unchanged. So you can see that you know um now one doesn't change but zero is getting reflected with respect to one um in general now let's say you apply uh this reflection transform to psi itself what happens is you have this bracket here, but this is a unitary matrix. So it's equal to one, and then you get two psi minus psi, you can sign. So applying reflection on itself doesn't change it, but what if it's orthogonal? What if there's a big function that's orthogonal to this and you apply it then you see that this this inner product is zero and then you get them and you're applying this on on phi and so you get uh this times phi and then identity times phi but you know this inner product is zero so you get just minus Phi so Phi gets reflected just like we saw one zero getting reflected earlier but now this is more general psi could be any direction and now for any general phi that you act upon now you look at this reflection transform what is it doing is it you know product here this psi acting on Phi minus Phi what is this doing this is making fine going negative the totally opposite direction but because we want the reflection to be with respect to psi we're having this additional term what is this this is the component of phi in the direction of psi right so and you add that twice so you reinforce it back because you made it negative let's say you had a cos theta you made it minus cos theta and then you add a two cos theta and so it becomes plus cos theta back again right so what what happens is when you do this, the component of phi along psi remains unchanged. But the other portion, the sine has become negative. And so you have reflected the component of phi that's orthogonal to sine. So thus, this reflection transform will reflect with respect to sine anything that you like. Asim Kadavig- Like I said, when you apply and you applying these matrices on these cubits or transformed version. Asim Kadavig- So now let's go back to what we said in the quantum search. We first will do this transformation, where we first will do this transformation where you know you apply the Oracle function which flips only this guy to minus 1 over 10 and then you know you do a reflection of respect to psi but you know now what your reflection means but what does the math look like so the Oracle transform what does it do it's making X K minus 1 over root n, right? So that can be written as subtract, because you had psi had 1 over root n. And when you subtract minus 2 over root n, then xk's component is minus 1 over root n. But all the others still remain as plus 1 over 10, right? So the oracle transformation can be represented as this. And then the reflection transform is like this. And we already saw what reflection happening on science and just produce a side to side minus side. These are the two terms coming from Italy. But then there's also the, this reflection acting on this part minus two over root n xk. And when you do that, there's a psi acting on xk and you get a one over root n, and there's a two over root n acting on this xk. When you do the math, you finally end up with a minus one over, one minus four over n psi and then 2 over root n xk where did this minus 4 over n come from this is because psi xk is 1 over root n and then you already had another root n and then there was this minus two so all of this give you a minus four divided by n now psi still contains xk so there is a one over root n times four so xk is amplitude y and one minus four four over n into one over root n plus two root n and if you look at this this is approximately three divided by root n but the other states now have reduced an amplitude they used to be one over root and now it's one minus four over n into one over ten so x k has undergone amplitude magnification and then if you kind of repeat this multiple times then you are very likely to select something with a very high probability. So the way I'm doing this, say for network access is if somebody, if some node has higher favorability, I would say the link conditions are better, then you apply the Oracle transform for that that entity so that its probability gets improved. But if somebody else's link condition improves, then you apply the oracle for that one so that you keep shuffling around the probabilities and then you can pick any one of them to actually transfer. So the process is applying this oracle to actually flip, you know, the probability for one of them and then do the reflection. And so you're doing amplitude magnification and that helps in finding what you want to find. So that's how searches are done. And then, so these kinds of things are basically done with the sequence of gates. And typically, these are called, these are the quantum computers that IBM, Intel, Google put out. They have, you know, a few tens of qubits. Now there's another class of quantum computers called annealing based quantum computers, which D-Wave works on. And those are slightly different. There you don't have the ability to synthesize any kind of sequence of gates and things like that, which the Intel IBM computers do. But what you have is they are in a matrix just like you know a GPU kind of thing you know all these processors are like all in a mesh closely connected and then's chilled close to absolute zero and you model the problem such that you search for the lowest energy point so so now what you do is you use you're trying to find this lowest energy state you're searching for something in that space and you're allowing all of these bits to interact with each other but you allow the neighbors to interact and so on so sort of a mesh where all these qubits interacting with their respective neighbors and then you evolve it over time to find the answer. So, and you have what are called quantum processing units and quantum machine instructions. And you can submit this quantum machine instructions to the quantum processing units. And then they evolve the system. One of the examples that we talk about is quadratic and constrained binary optimization we're trying to find the states of all of the qubits such that the energy is minimized so you have these weights corresponding to all of these variables and you have a function and you want to assign values to the state such that this function has the lowest energy so here's an example so there are four nodes and they could be self loops so if you say I'll pick zero then the energy goes up by three point four or to reduce the energy so you'll say hey I'm not going to pick zero because you know this the coefficient in front of it is 3.4 but I'll pick three hey that's negative so let me pick that so let me drop all of them and let me just pick this okay that maybe that's my lowest energy state I just have third bit assigned to one and zero zero zero but no hey there is also coupling between these bits like zero and one are coupled zero and two are coupled and there's energy associated with that but we are trying to minimize the energy right so maybe we pick the ones that are negative so we could say let's pick two also because two and three are negatively coupled okay but if you pick two then okay i'm increasing uh uh reducing the energy uh pi minus 3.22 but let me see if you know adding two is mixed worse no actually fine I'm fine because two is 2.1 and the coupling is more negative so it's okay to add two but is it okay to add one look one is if you add one it has a self coupling of 4.5 and then combined with two is another 4.5 and one three is another 4.5 you would just increase the energy a lot so you wouldn't bother to add one what about zero you add zero zeros couplings are also highly positive there's a negative part but there are more positive parts that over uh override the negative so at the end you'll say okay I think my final assignment is 2 gets a 1, 3 gets a 1, and 0 and 1 gets a 0. That's what the D-Wave solves and finds the final energy is minus 3.52 which is minus 2.4 plus 2.1 so you're at minus 0.3 and you just do 2 and 3 and then you take the coupling between 2 and 3 is minus 3.22 so that's minus 3.52 that's the energy of the system hey Dilip can you ask a question yeah I have some basic question very basic questions so what is qubit? Like very layman's term if you could explain me what is qubit? So essentially think of that photon right or in a superposition of states and you're allowing it to be in a superposition of states. You saw the Hadamard gate, right, which actually takes it into an entangled kind of form, so it rotates it. And so, you know, if you had measured it and say it was actually in a state zero, by putting it through the Hadamard gate, you actually end up in a state zero by putting it through the hard MR gate you actually end up in a superposition that you can manipulate so so what you do is you end up utilizing the superposition and you let's say you multiple photons you of them interacting with each other they are all in a state of superposition. You allow them to continue interacting with each other in the quantum realm, then you make a measurement. If you do make a measurement, you can still, you know, apply Hadamard gates and then things like that, and go back to kind of cross coupled states and things like that to actually work with these qubits again in the quantum realm. But essentially, a qubit is saying, hey, I may be either in state zero or state one, but you know, and these are the probabilities that I may be in. And so in software, if you try to simulate this, what you will see is, you know, I have a head or a tail, but I have probabilities associated with the head and the tail. And you represent, let's say a JSON object with head and tail and the probabilities associated with them and that you will call as a cube. I see.. In software you would have just said head or tail but if you try to write a qubit you will say I have two possibilities for it head and tail and these are the amplitudes for it and the squares are the probabilities. So just define that object and then when you try to implement a quantum algorithm you manipulate with these quantum data structures repeatedly and you can apply these matrices and things like that then you can make a measurement all in software you can just do this in classically on a classical computer but just represent them in this form yeah i see and so quantum search is basically search for that qubit state one any of the qubit state right uh you're trying to search for some particular item something that's higher you know more important to you or you're trying to find something that's uh more highly probable but you essentially you have to but you essentially you have to apply an Oracle transform towards that so you have to keep applying the Oracle transform to a system to keep trying you know maybe different variations different items to see if which ones are important and then amplify them so but your external input may say hey this is what I want to amplify for example like I was saying what I'm trying to do with network access is I want to give access allow access to a network to a node which has a better link condition so when I find that then I am I work with a quantum state but I amplify the state of that particular node because it has a higher link condition so that if I make a measurement most more likely than not I will pick that particular node and allow it to transmit so so what is the the Oracle functional record transform if we other than can you try to define it other than non mathematical terms like I mean the method so the also this the Oracle tries to differentiate that particular state state you know that minus xk um you know xk became minus xk right so uh when you try to do this reflection with respect to uh in a particular direction the um because uh all the others did not change when you reflect they will all go somewhere but the one that is minus actually flips back with a stronger you know force in and reinforces itself in its original direction and therefore it undergoes an amplitude magnification so you flip it and then you reflect and then it ends up having a stronger amplitude that as the others you know go down in amplitude after the reflection yeah that helps understand thank you very much yeah so I'm almost to the end so yeah there was two things that the Oracle followed by the, earlier here, let's one more example here. If we add one more qubit to this system, again, you'll see that it's decides to do one zero one one one and you can work through the math and basically doesn't allow one four to go on but everything else if you add up say so one is rejected right so you add this and this will get plus 0.7 right and you've rejected a one right but one is rejected. So take 3.4 minus to Shaleen Gupta- Combine that with this guy, this guy, this and this will end up Shaleen Gupta- Having minus 18.12 so point one two so um adding up all of these guys getting your minus 18.82 and then this guy you know plus 0.7 so you end up as this is the lowest energy system so uh but note that this kind of computer is not what we were talking about earlier it's only allowing some interactions to progress between uh qubits locally because it's like a mesh of qubits that interact with each other but you can you know change the weights of the correlations between these qubits too and then allow it to converge and where is it useful for example they try to do map coloring with this or to figure out a solution to color different regions by assignment of states with respect to color for every region and map and things like that. And then it settles down to something that doesn't have any conflict or minimal conflict and so on. But this is more like if you've heard of annealing and things like that optimization. This is an approximate solution. So what D-Wave tries to do is not like a perfect classical algorithm. The IBM, Intel, Google computers try to do those classical things a perfect classical algorithm the ibm intel google computers try to do those classical things you have a fixed algorithm you know exactly what you get here it could be an approximate thing and you let it settle down to some minimum energy and you take that as your answer you go is this so delete this is is this something like uh what we do in like machine learning where we try to you know reduce the error or something like that to a certain degree of inaccuracy yeah yeah you can think of it that way but then yeah you have to uh have you have to have knowledge of uh correlation so they think of it somewhat like a clustering problem trying to partition and you're trying to uh you know things that are getting strengthened are belonging to the same cluster and things that you know that are not uh um strengthening things that are weakening both the opposite cluster kind of thing so it's trying to create a partitioning and and then an allocation for the problem so if you have an exact algorithm you will go with like the IBM Intel Google kind of point computers to and build a sequence of gates and you know and you write it as a sequence of matrices from left to right the leftmost will be the last matrix operation that you perform whereas with the D wave kind of thing you're trying to kind of find a solution to a problem by mapping it to this kind of quadratic optimization. So these are called, these energy functions are called Hamiltonians also, and you're trying to find the minimum energy state of the system. And so it comes from physics, but then you translate that to an actual problem in computing, and then let the quantum computer do the physics and give you the answer. So these are some books that are useful. The second one is probably the most useful for, and you can actually get a free PDF online. It's the most celebrated book in this area, Nielsen and Schwann, Quantum Computation and Quantum Information. The first and third are more physics related for those who are curious about, you know, how Schrodinger's equations work and things like that, if you're interested. And there are a lot of Wikipedia and online lectures from different universities, MIT, UC Berkeley and so on. And then D-Wave also has some documentation. It does a slightly different kind of quantum computing, more approximate quantum computing. So that may be interesting as well. And for me, I see this as part of a bigger scheme of things where we may have AI, ML, IoT, 5G, and blockchain and so on. And 5G can allocate resources and networks. IoT systems can monitor and provide triggers for processing, and have blockchain systems executing smart contracts, recording events. But you can also have content-inspired algorithms as well, executing in virtualized infrastructure. So that's what's driving me to kind of, because I have to kind of look at future technology as well, so I'm trying to see how to integrate quantum-inspired processing as well. So yeah, I was just walking you through my own journey in this, what I've been trying to learn. Hopefully, you'll be able to share something. If you have any questions. This is Amitijit again. That was great. You kind of very nicely combined both the theoretical and the practical aspect. This was very nice. Thank you. So just Dilip, can you hear me? Yeah, yeah. So we are doing like a quantum searches in your example. So you are constantly taking measurement of all the nodes and just doing a quantum search for a best node and trying to route the traffic through that node is that the concept? Oh, for what I'm trying to do? Yeah. Oh yeah. So I'm trying to apply it to networking for example. and maybe you know all the different nodes are different possibilities so of who would transfer next so I have to pick one of the states or to say with whom I'm going to pick next to transfer so I'll try to apply Oracle transforms when nodes are more favorable in terms of getting access to the network because their link conditions are better. The other thing you can look at if you're talking about routing would be which path is less congested and you could apply an oracle transform to that less congested path and make it more favorable apply quantum algorithm to select the best route so you can keep applying it to different types of problems yeah I see so this will be I think very beneficial for network slicing type use cases right yeah yeah yeah definitely and not only in networks I mean so people have started see the thing is you know we don't have to actually run these things on quantum computers we might actually by creating some quantum algorithm, quantum-inspired algorithm, you could evaluate a superposition of states. But what I think we have to do is not let it just run completely to the end. Because let's say we create two raised to n threads for each of the possibilities and let them evaluate each one of them. Then you didn't gain anything, right? Because let's say you started with some random initial state to find what the answer is. Let's say you tried all possible initial states and you have threads running all of them concurrently. And then you find which one is the best one. That's like brute force. So what you have to do is you start exploring, but at some point you have to do is you start exploring but at some point you have to take a call, okay I'm going to stop searching along these paths. Just like you know you know how a computer plays a chess game, right? It's nice to evaluate different things but it proves out different paths. So we have to, if you think quantum inspired, you're thinking of a superposition of states, you start narrowing down and then again, try to go quantum and then again, come back and narrow down. Eventually you probably will be picking the one, you'll be finding one that you're looking for. So, and hopefully by doing that, you will get a faster speed up, on a classical computer just by thinking quantum how we try to solve the problem and and people have tried to apply to recommendation engines also trying to explore different possibilities but creating a data structure which is as if it's a superposition of states exploring what we should do is you know pause and then you know that hybrid thing of classical versus quantum kind of thing you should keep doing that and you know when you think of parallel computation you have this computation this communication and you know you have this interleave phases of computation communication we should when you do that computation you do the quantum inspired and then you have a phase of communication to kind of reconcile your results to try to decide how to focus you know your energies on the next stage of computation I think if you try to if we try to design algorithms that way maybe we'll get very interesting results even classically but once the quantum computers can be used for that you might get a higher performance as well when you observe the right your your wave you the wave wave function collapse and it becomes particles then we try to entangle the particle becomes wave again is that the concept it remains you know it's neither of you found a particle but you know you can call it a no Chandra and I had a professor at ITM at our school which was the politician would call it a varico but you know like like you said you know when it goes through that polarizer and it's still a wave function coming out in the x direction right so it's but but it has a definite state associated but yeah you're right and then you can apply the you can create an entangled state if you like and things like that after measurement and and so then you go back into the quantum state of superposition of these cubits you have fun with it and then again you take a measurement like you just said and that can be. We can try to some interesting competition. Sanyam Bhutaniyya, Yeah, so when you try to create an entangle, how are you going to save that information, what kind of data structure, you will use to save that entangled like Sanyam Bhutaniyya, So, when we write a computer algorithm, we can actually save it in the sense, you know, it's a data structure in the computer with different probabilities, but in an actual quantum computer, you can't see it. Ayush Chutani, Right. Ayush Chutani, If you make a measurement, it will collapse. So actually you have an advantage if you write a program which is quantum inspired, you actually can see the probabilities because you're evolving the probabilities as you go along. Ayush Chutani, because you have a data structure to represent the entangled state right but the actual quantum computer you're at the mercy of the physics and you know the probabilities are evolving internally all you can do is take a measurement and see what it provides us an answer nice this is the software level okay yeah so you could do completely in software, then you have access to everything. But when you abstract the quantum computer out, the actual physics part of it out, you don't have access to the actual probabilities associated with states. You know the states that it could be possibly in, but you don't know the probabilities associated with them. And it and it collapsed one of them okay any other questions yeah so I have one question so what kind of physical systems you use for the making these qubits like these two photon states or two quantum states? Yeah, so they have, they use this superconducting systems, super cool, you know, almost a zero degree Kelvin kind of thing. That's for the D wave? That's for the D wave? DV yeah all the computers are like that operating at very low noise levels it has to be super cool so that you know noise is extremely low so that the probabilities are preserved and things like that and then you use these polarizers and beam splitters to kind of do this gate transformation such as the Hadamard Gate. So it's a lot of superconducting conductivity physics that's going on. And Asif can probably tell you more about how these physical, how the physics works. But what happens is that, okay, what the physicists will do is they'll say, okay, look, this is what you, this kind of operation is what you want. I will do it in my quantum computer look this is what you this kind of operation is what you want i will do it in my quantum computer and this is my result uh so you know you don't have to worry about it like you know you saw the quantum machine instruction right all you have to say is you have to issue the instruction and internally the physics will execute that instruction on these photons execute that instruction on these photons. Okay. Thank you. Thank you for the nice talk. Yeah. One thing to add from a physicist perspective, see the quantum computing theory like Dilip explained is ahead of the physics. It's very well developed. There are remarkable things that are arising. It's becoming popular. You can use languages to do quantum computing, at least simulating it on ordinary computers. Physics will take a little bit of our time to catch up. Just two, three days ago on June 25th we had a fundamental milestone in this. I don't know, some of you may have heard about the CubeSat. There's a satellite and on that satellite for the first time quantum quantum entanglement was actually observed and it's quite a quite quite exciting actually for the physicists community oh okay I didn't know that that. Thanks. Dilip, just one last question. Yeah. How heavy of computation it is, right? Like on that's a node, like you need a lot of computing power or software? Yeah, actually these systems take a lot of energy. But hopefully the, you know, Actually these systems really take a lot of energy, but hopefully they can solve a high dimensional problem much faster and therefore it would be worth it to those on these computers so in terms of 5g network for example can you implement it at the edge device edge edge nodes as well not at the edge device oh no no no no nowhere close to that right because these are this will be some super cool things sitting in some uh specialized locations somewhere so what you have to do is you have to send all you set up the problem, send it to the quantum computer. Ask it is almost like it is almost like the olden days. We used to put punch cards in the mainframe. Now, there'll be a bit of latency to access this thing. So it better solve this higher dimensional problem for you but you know that there is this this part but there's also this part of being quantum resistant which is uh you know if you do all your uh computation just be quantum resistant so a quantum computer could do some prime factorization and break your photography and so they say this is just using sharp I 12 from now on sharp 3 by 12 for your hashing so that quantum computer targeted you need about 1 3rd the qubits to target a hash and see if you want to target a 256 bit hash you need about 85.33 qubits about 86 qubits and you already had like 70 qubits so 256 is one so but with 512 you need about 171, right? So, qubits. So, that may still be a far, a long time to go. So, SHA-3 512 keeps, whatever you're doing classically secure prevents a quantum computer from breaking. So, you know, you can continue doing your work classically, just make sure your encryption happens in a higher dimension such that you know or hashing happens in a higher dimension so that you know quantum computer even with its potential will not break. And then you don't have to worry about quantum computers. But if you want to use quantum computers then you would do this. You would try to map your problem to a quantum computer, send it, send QMI to the quantum computer, let it execute. And then you could also try to do quantum inspired software as well. Okay, excellent. Thank you. Any more questions guys? I have just, this is Avijit again, I have just one last question. So those physical quantum machines, right, the physical, the CNOT and the Hadard gates, are those, so if suppose we have to do it in the physical machines, not using the classical computers with the quantum inspired algorithms, then are those gates built into those machines or like I'm just trying to visualize what those machine I mean I understand of course you know there is there are all the pipes moving around with the you know cooling and all those things happening. What is that exactly? They have this kind of polarizer it's like a green pyramidal thing and it's say set set at 45 degrees uh angle to the photons that are coming in and so that causes um you know the bell states the plus and minus states you know that for plus and minus 45 degrees so um whenever you ask for it then it will produce photons put it to the polarizer and the output photons would actually be um in this uh in these bell states that can be subsequently processed until then you know you're not doing anything until you ask based on the problem that you're going to solve it has to be kind of configured that way yeah yeah yeah okay okay okay so the so the q and the qubits the number of qubits and all you have to configure it that way basically yeah yeah but what i'm saying is that maybe see what quantum algorithms are trying to do and see if you can even classically have fun with it right um without even having to talk to quantum computer. But all of these things, all of these computers are available in the cloud and get access to them as well. Try out some fun stuff. And there are simulators available as well. Okay. Like Google Cloud? Are they available in Google Cloud? Yeah, should be. I haven't tried it. Maybe ask if you know, I don't know. I think it's a service that Google exposed, I believe the D-Wave and so forth. D-Wave, yeah. D-Wave exposes its own service. But yeah, Google, all of them have it on their respective clouds. So you have to connect to the cloud and then ask and usually though if you're in academia you have more resources but if you're not I think they give you very limited resources like the IBM quantum computer will give you a little bit of time but it's still adequate to kind of fool around with it but then after that i think you're paying for it and there's this whole emerging field of quantum machine learning ah so as if you want to throw some light on it that would be a big topic perhaps That would be a big topic, perhaps a follow up talk on it. There's a very interesting intersection between quantum. Actually, all of these things are merging. The whole mathematics behind machine learning is so close to physics and quantum is physics. So there's a gradual convergence now of all these things. Yeah, yeah. Yeah, and it's fun and it's kind of... Okay, if enough people are interested, I would like to talk about quantum machine learning. It's a little bit far out there at this moment, a little bit away, but it's one of those things that you dream of today, you build that theory, by the time it becomes practical or real it's another 10 15 years yeah it should be fun I should explore yeah we should explore the repay thanks a lot this was a Muslim thank you just the welcome practice in actual reality here. This is I wish I wish the audience could see you if your video worked. Oh yeah, sorry about that. I don't know what the problem was. In our separate a photo. Still look like that. Yes, in the in the in the video that we put advertising this talk. All right guys, thanks for. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you Dilip for the talk. Thank you Dilip. Very nice session. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you, Asif. Thank you, Asif sir. Thank you. Thank you. Thank you, Asif. Have a good day. Thanks, Harini. Thank you. Have a good day. Bye. Thank you. you