 All right guys, we'll start. All right guys, we'll start. It is my pleasure and pride to present our speaker today, Dr. Dilip Krishnaswamy. He is an extraordinarily accomplished researcher and scholar whose inventions have led to over 50 patents. He has authored over 100 articles and over a hundred articles and... Excuse me. I apologize guys. So he has authored over a hundred articles and research papers and presented at conferences worldwide for the last three decades. He entered IIT Chennai as one of the top rank holders in GE and went on to finish with academic distinction. Subsequently, he did his doctoral research at the University of Illinois at Urbana-Champaign in computer science. He went on to continue his research at Intel, Qualcomm, IBM, and now finally he is the Vice President at Reliance Industries, leading research and innovation. We met when we were young in graduate school years of doctoral studies, and it has been a matter of pride to have known him as a lifelong friend. Today, he will now be speaking on quantum computing. Today, he will now be speaking on quantum computing. Dilip? Hey Asif, thanks for the intro. Yeah, it's been fun in this life knowing Asif. I hope I get to know you in future lives as well. But for me, Asif has been a wonderful soul. He's been part of my journey. So thank you, Asif, for being there. And I just want to talk about some work that I have started venturing into personally, just out of interest, and thought I would share some of what I've learned. And I'm still learning and maybe able to answer some of your questions and not others. But I will plead ignorance if I don't know. But one of the things that's going on with regard to the work that I'm doing is that we are deploying like future 4G, 5G, 6G kind of networks and in that the infrastructure is getting increasingly virtualized. And I just wanted to give you a context of where the research is coming from. The infrastructure is virtualized. Everything is executing as microservices and containers or virtual machines. And you may have like a cloud data center, an in-network data center, an edge data center, things like that, and these microservices executing tasks. It's not just about the network, but it's also applications and services and things like that. So then there's, as you all know, there's this trend towards just aggregation with microservices. And we've started working on AI ML algorithms and blockchain. And so we can think of quantum inspired algorithms as well to execute inside these microservices. Some recent work has happened where, somebody was trying to create a recommendation engine, but just by designing the algorithm in a slightly different way, as if you're exploring a superposition of states as you go along in your search, but executing it on a classical algorithm, classical computer itself, that itself gives different benefits benefits and improvements and you know the results that uh come about so you know um people worry about when quantum computers will be available and things like that but maybe we don't have to wait maybe we can just write our algorithms for instruments by seeing how uh you know, businesses and engineers have tried to build quantum computers. And you know, when the computers do have a lot of qubits available, we could also use them. They're already available, but you know, they can probably solve smaller dimensional problems right now. But we don't have to wait is what I'm saying. We can think quantum in the way we design a local and see if that leads us somewhere. And people are just beginning to do that. So maybe this talk will lead you down that journey. So just getting back into quantum, there's this famous double slit experiment that you would have seen probably in your 12th grade studying physics and trying to find out what's the distance between the peaks and the that fall on the screen in the back. But, you know, when we studied that in high school, we thought of light, a whole bunch of photons going on a screen which had two slits and then you would get this interference pattern. So we used to think like these were waves and they were interfering with each other and so you get these peaks and troughs and all of that. But the interesting thing is, the funny thing is, if you slow this down and just you know you're sending 100 photons maybe slow it down to 50 photons 10 photons five photons finally bring it down a single photon that you're throwing at the slit but you send a photon at a time and then you observe the pattern over time you'll still see this interference pattern, which sounds crazy, isn't it? I mean, in the sense that a single photon had the knowledge about the probabilities in the system to actually work with the future photons actually produces interference pattern. So what's happening is that this single photon has exhibits characteristics not only of a particle but also of a wave and as you know probabilities associated with where which path it will take to finally end up on the screen. And then when you take a collection of photons, you actually get this. So it's neither a wave nor a particle actually, but you define it as if it's a wave function function with a certain behavior and the different paths that it can take are all in superposition and at some point just before observation it ends up taking one of the paths or at the time of observation. So people have even tried to peek at the other side of the slit to see, hey, can I see what's happening to the photon? But the moment you observe it, it's taking your forcing it to take a decision. So it's really funny. But in quantum realm, the qubit or these quantum particles stay in a superposition of states until you mess with them and you try to observe them and then they collapse to one of the states. So you never know what it was, what state the photon was in, or what superposition of states, what probabilities they were in. When superposition of states, what probabilities they were in. When you make a measurement, you just get one of the states. So and then it's deterministic after that. So this double slit experiment had this interference pattern with this constructive and destructive interference, but still get it even if it's a single photon and so each each particle is in a superposition of states and the measurement collapses the state and uh i'll just introduce a few equations but we'll quickly go to the quantum computing part. But some of the properties are that, you know, like a photon has energy. We say h nu or hf, right? But there's also this reduced Planck's constant. That's another way of writing it as h cross omega, and which is h by two pi. And similarly with the de Broglie's equation, you're seeing lambda equals h by p, but you can write p as h cross k. So where k is called the wave number, 2 pi by lambda. So there are two different ways of writing the equations. If you introduce the 2 pi and you use the reduced Planck's constant. And so typically you use k and you use omega rather than f and lambda. And then the energy, let's say is a P square by two M for a quantum particle. The phase velocity, if you look at would be omega by K. And then if you just take the energy divided by the momentum, this omega by K, you can multiply this h cross and the numerator and denominator, and you get E by P. But then it looks like it's V by 2. But actually what's happening is it's not just a single particle, it's a group. It's a packet that is constructed by superposition of waves, which has a group velocity, which is given by this d omega by dk. When you do that and you still multiply these H's, you get dE by dp, which, and then the two cancel out and you get the speed. So that there's actually, the particle is moving as a wave packet, is moving as a wave packet, you know, as a combination of, as a superposition. And this, if you think of, it may have some characteristic lambda or wavelength or this wave number, this omega is typically a function of that. You know the frequency. You can find the frequency once you know the speed and wave length. So the omega is a function of k where k itself is not discrete. Like, it can be a continuous function. Think of it like a Gaussian function with a very sharp peak. And so, and that's the group of waves, you know, that's actually moving in this case. And so I'll skip all this, but it turns out that, so Asif didn't want me to throw you too much of equations from this side. But at the end of it, it turns out they all obey what are called Schrodinger's equations. This is for a free particle. There's another equation in the presence of a field and so on. But the interesting thing is that this kind of differential equation is linear in the sense that if you have psi, let's say you have psi 1 and then you have psi 2, you can linearly combine this so that you can have, you can think of linear superposition or weighted superpositions of these superposition or weighted superpositions of these wave functions. So when we talk about quantum computing, what's really happening is all these physical phenomena are happening in the background and we just abstract it away with this notation and then we forget that hey all of this integrals and differentials and all those things are going on out there so now and the thing is you don't have to really worry about it I mean the physicists will take care of all of the physics behind it what happens is that a whole bunch of different types of operations can be performed on what are called quantum bits. And you don't have to worry about how it's getting done inside the quantum computer. It's just like you, you know, when you do digital design and you have NAND gates or NOR gates and things like that, you can combine these gates any way you like to realize some digital function um in the quantum realm also you have a whole bunch of functions that can be realized and all that they do is that they work on the bits and uh the operations are uh matrix operations on those bits and uh you And when you do some computation, when you go through a sequence of gates, you're just multiplying one matrix after another. So, and the end result is a product of all the matrices, from right to left, the leftmost is the most recent operation that you perform. So now you have available with you a library of gates that you will work with to actually operate on qubits and try to do some fun stuff. So I'll try to explain how a couple of things like quantum search and quantum optimization get done, but just some preliminaries about how you work with these qubits right now. So this wave function, let's say you have, we said, you know, the particle, the state of the particle is not known until you observe it. And when you observe it collapses, it'll collapse to either zero or one. So let's say there's a particle with two states, you know, and describe these two states as a zero and one. This can be like spin up or spin down and things like that. And there could be a probability associated with each of these states. And now these are the sign, this notation, a vertical sign, followed by this weight function, followed by the right arrow you know that's the description for the wave function now you write that as the summation of this possible states of intake zero or one and these are called amplitudes what's standing in front of the zero state and the one state. The probabilities are the squares of amplitudes when they're real, but you actually take the complex conjugate and then multiply that to actually get it. These amplitudes can actually be complex. The notion for complex is basically that there can be a phase associated with the notation if it is not real. But just that phase is getting captured as a complex representation. So, So what you have is there are two states, there are probabilities associated with the states such that alpha one squared plus alpha two squared equals one. Think of them as real for now. And just that what you have here is a square root of the probabilities. So if they were equally likely, the probabilities would be half and half. So what would alpha 1 and alpha 2 be can anyone tell me what would be the answer the probabilities are half right alpha 1 and alpha 2 alpha 1 square and alpha two squared are the probabilities. So alpha one and alpha two will be? So alpha one squared is half, alpha two squared is half. Is it 0.707? Yeah, yeah, right. One over root two, one over root two one over root two and you'll see that you know uh it'll continuously getting used so so don't when you see that don't get scared hey where's this square root of two coming from it's just and we'll see what this means why uh in just a bit, or why there is a square and things like that. It actually relates to energy. So what happens is that typically light, as it's traversing, it's a transverse electromagnetic wave the direction of the electric field is is called the polarization of the photon electric field is oscillating in one direction the back click field is oscillating in a perpendicular direction and the wave is propagating perpendicular to both of them e cross h so the um uh and the direction of the electric field is called the polarization. And if a photon arrives at a polarizer, and magnitude is a at a triangle alpha, then a cos alpha is the amplitude that is transmitted through the polarizer. And then the thing that's perpendicular to it will be filtered out. So the energy of the wave is proportional to the square of the amplitude and hence proportional to cos squared alpha. So cos squared alpha is a fraction of energy that gets transmitted past the polarizer. So think of the probability as relating to energy, right? You have amplitudes and the probability relates to the energy of the system. So there's a probability cost squared alpha for the photons to go through, depending on the polarization and the direction of input. And so what you say is before it hits the polarizer, you know, there's a component um say along x that that is going to get transmitted that component has a value cos alpha is a component y that's perpendicular that's going to get filtered out so it's in a superposition of states with amplitudes cos alpha and sine alpha. Once it gets through the polarizer, the state is just this photon X, right? It's just more, has a component only in this X direction. So there's now this amplitude is one. There's no more of this Y. Okay. So it's at this point. So what happened was that this, this cost square, cost square alpha was effectively how much energy went through. If you put out, put through a whole bunch of photons to the polarizer, the total energy coming out will be cos squared alpha of the input energy so that's where we can start thinking of what these probabilities are they relate to energies in the system now and as you said, these quantum particles in a superposition of states, but if you try to observe it, the moment you observe it, the state of the particle collapses. It'll collapse to either zero or one. But it depends on the probability. So if the probabilities for say state zero is higher than the probability for state one, and then there's a possibility that when the collapse happens it'll actually go to state zero instead of state one and vice versa if one has a higher problem and that is what is used in say a quantum search algorithm where what you try to do is you try to manipulate with these probabilities such that when you try to collapse, you end up with the answer to the problem because the answer to the problem has now achieved a higher probability through the manipulation through quantum gates in the system. And we'll see how that is done. So the moment you observe, you have no, you have completely lost information about the probabilities that that particular quantum particle had. All you know is what state it took. So it's possible that zero was higher probability when you measure, you get a one. So you have no knowledge that zero was indeed a higher probability at that point in time for that particular photon. And because of this, there's also this thing called no cloning theorem. That is that you can clone a digital bit, you can copy one a bit with its either one or zero to some other place in memory but a quantum particle cannot be copied because we don't know the probabilities that it has so that's so you have to live with that you have to live with all these ad synchrony synchroses and still try to utilize this hey this is this is Avijit can we ask question in between or towards the end? Yeah, go ahead. Please ask. Just one question in the previous slide. You don't have to go back. You said that we don't know anything about the states. We just know once we observe whatever the state it is, that's what we know. So we manipulate it by transforming. So how do you transform if you don't observe? So I'll come to that a little later. But you but you use you keep the qubits in the quantum states and actually apply what say if you can do a hard amount gate which is actually trying to entangle qubits which which effectively is implemented by putting it through a polarizer, beam scooter, and then out comes an entangled set of qubits, which you can work with. But the probabilities get carried through in the process, and we'll see how that happens very quickly. Okay. Yeah, I think it would appeal thank you yeah so um so the typical convention is zero is represented as a column basis one zero and one is represented by the column basis zero one and then the wave function as a superposition is represented as alpha one one zero and alpha two zero one So actually just leave it like this rather than this. And then if the two states are equal probably like we just discussed it's probably 1 over root 2 and 1 over root 2 and that could be minus 1 over root 2 and 1 over root 2. And they can be on i also in this out here. So out here. So we can have another quantum particle, B, which can be in a similar superposition of states, but maybe the probabilities are different, such that the sum of the probabilities is one. Now, when you work with multiple qubits, you have to think of the combined state of Raja Ayyanar?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam?nilam the tensor will see exactly what it is in just a bit but if you try to you know expand it out you can see that you get alpha 1 beta 1 and then 0 0's getting less scary, right? So you write this guy as just 0, 0, 0, 1, 1, 0. But now if you write that, so the two particles, this is the combined state alpha 1, one zero zero one and if you uh take the squares of all of these things and you add them all up uh you'll find that some of the probabilities are still one can somebody tell me now uh if you have these four states what would be the if they're all equally likely what would be the numbers sitting in front here yeah half yes because half square is 1 4 1 4 plus 1 4 plus 1 4 plus 1 4 so it's of 1 over square root of 2, you have halves. Two bits are more fun. You don't have the square roots anymore. OK, so this is what a tensor product looks like. All you do is you take this column vector, and then this column vector. And so this is 0 and 1. But let's see 1 applied to 0 kind of thing so that the vectors look different. So this 0 we said is 1, 0, right? So you keep repeatedly applying the bits associated with this column vector on the other column vector for 0. So this is 0, this is 0, and then one was zero one, right? So zero is applied to one zero, and one is applied to one zero, and you get a four dimensional column vector, which is zero, zero, one, zero. And similarly, say one, one, zero, one is applied to zero, one up here and down here, and you get zero, zero, zero. And similarly in zero acting on zero, you get one zero zero zero. So you get all four possibilities. This is like one hot encoding, right? So you get one zero zero zero for zero zero, zero one zero zero, zero zero one zero, zero zero zero one. Now, what if you had a third qubit? Can somebody tell me what this column does? If you repeatedly apply, what do you had a third qubit? Can somebody tell me what this column vector would look like? If you repeatedly apply, what do we have to do? You have to take each one of these guys and then let's say you have to apply it to, it acts on a one. Then what is the length of the column vector? column vector. Each of these entries in this column vector is acting on this two-bit column vector. So how long will it be if you have to apply it to another qubit? Eight. Yeah, eight, yes. And then you can build it. So that's called a three qubit register. Then you can grow any number of qubits. So So 0, 0, 1 is like this. And then these are the four possibilities 002 qubits. There's another rotation, which is called the inner product, which is basically the mirror version. This is called a ket and this is called a bra. So this inner product is called a bracket operation and it's actually obtained by using the conjugate transpose. And if it's real, you just take the transpose and just multiply. And so it's like a dot product kind of thing. So you just and these were these were our column vectors, right? These buckets were our column vectors. So if you take a transpose, this becomes a row vector. So the row vector acts on a column vector and gives you a number and that's for the inner product so we will we will see the usage of this a little later um so then there are uh unitary transformations that you have like i said when you do quantum computations you're're applying unitary matrices to transform them. And this basically entangles them, helps in entangling. So we'll see how we actually entangle it a little later. But so a unitary matrix has a property that if you, you know, apply it to itself, you get an identity matrix. So you apply H to itself, you get, say H is this matrix, which is trying to, the first row is just copying over. It's not changing, but this one is flipping the second component in the column so so what does it do we'll see a geometrical representation of that but you can see that if you multiply this matrix twice you end up getting the identity vector so So it's unitary. And when H is applied to zero, so you have this H matrix and you apply it to zero, you get one over square root of two, one, one. So this is like at 45 degrees, right? And so, and this one is one minus one. So this is sort of like a minus one. So this output, when it's applied to one zero getting transformed to this also called this plus state, it's also called a minus state. It's also called Bell states. But geometrically you can see what's going on. One zero is zero, right? Let's draw zero on say what's the x-axis. It's going rotating to 45 degrees. So I say, hey, is it a 45 degree rotation? But then look at one. One is let's say up here pointing towards the y-axis. But if you rotate it and have one minus one with one of square root of two, it's actually pointing downwards here to minus 45 degrees. So, it's not just a rotation by 45 degrees. This guy's rotating by 45, but this is 135. And this is anti-clockwise, that's clockwise. So is there another way to look at it? You can draw a line at 22 and a half degrees and say, I'm gonna reflect at that. So you left reflect along pi by eight. And then, yeah, hey, this guy goes here, that guy goes there. So this is one interpretation. This is a reflection transform at the angle pi by eight. But there's another way of looking at it, which is first rotate clockwise by 45 degrees and then reflect around zero. Okay. So, oh, by the way, if we go back here, we said these matrices are unitary, right? So if you apply to itself, you should get back what you got. So if you define this as rotation around pi by eight, this goes reflection around pi by eight, then this goes here, and if you reflect it back, it just comes back here. So this guy goes here, and then you it back it just comes back here so this guy goes here and then you reflect back just goes back there right so all that so you can see that when you apply a second time you just get back what you started so let's see if that works here also in this thing what happens is here we get the other interpretation is let's rotate 45 degrees clockwise and then reflect it around zero so then it goes here this is fine right that's this guy what about zero one one rotate clockwise by 45 degrees it reaches this here and then you rotate it around zero so close down here so so yeah you can rotate by clockwise and then reflect. What if you reverse the operation? If this guy, so now we have this as the result of applying the matrix once. If you rotate clockwise by 45 degrees, you end up at 0. And then you reflect around 0, you stay where you are. What about this guy? You rotate clockwise by 45 degrees, you end up at zero and then you reflect around zero you stay where you are whatever this guy you rotate clockwise by 45 degrees you end up here and then you reflect and then you end up back there so you still both interpretations get you the same answer so there but here what you would say is you would apply a rotation matrix followed by reflection matrix but this rotation matrix is for pi by four whereas the other one would just say reflect with respect to the pi by eight dimension right so effectively all that's happening is these are matrix transformations that are happening and you know and then you apply them in sequence. There are other types of gates. There's an identity, there's an identity gate. This is a poly matrix. These are poly matrices. Asif can tell you a lot about what all of these mean in physics, but relate to spins and all of that stuff. But for us, it's an abstraction that it's just a matrix that you can apply multiply but this one you can see just flips the bits so it's also called a not gate matrix and this is another gate called a c naught gate which flips a target bit if a control of it is a one so and it's very useful extremely useful for entanglements to So see what it does. So you have this, let's say four different probabilities, 0, 0, 0, 1, 1, 0, 1, 1. Now let's call the first bit a control bit. So if the control bit is a one, then it's going to flip, right? So it's not going to change. If this guy's the control bit, if it's zero, it's not going to change. So this remains unchanged. This remains unchanged. But here, the control bit is a one. So the second bit flips to a one. And here, it's a one. So the second bit flips to a zero. So it selectively flips the second bit if the first bit is one. That's an interesting property that the SCATE has. And in general, you can have K qubits and so two raised to K possible states, like you said, when you have three qubits, we have eight possibilities and so on. And then you have each of those states can be all possibilities, and then they can be aptitudes associated with states. And so when you're trying to search for something and you're trying to find something which is highly probable basically you're trying to find the one which has the highest amplitude so this is a single qubit register right this is a two qubit register right this is a three qubit resistor right and so on right so um order to worry about tensor products anymore it's all just all looks like this so now comes a very interesting thing called quantum entanglement which is a phenomenon where you actually take two photons but if they could be directly entangled or inversely entangled in the sense if one if you make a measurement on one of the entangled photons then you you can re observe the state of the other and if you observe the state of the other photon it'll end up if they directly entangle it end up being the same so observation of any one of them collapses the state but it also immediately collapses the state of the other one even if you didn't observe it so you can observe it go and observe at any point later in time and you'll find that it is what it would have collapsed to. So you entangle them, but you could be mostly entangled as well. So the quantum entangled state would be represented like this. Like, if it's directly entangled, if one is 0, the other is a 0. If one is a 1, the other is a 1. And then you would have 1 over square root of two. It's coming back to onto zero. These are the Bell states. But it's not decomposable anymore. Like you can't write it as, you know, the state for the first qubit tends to product with all possibilities to the second qubit. Now that you only have zero zero and zero one as possibilities so you can't decompose it individually and that's why it's entangled and you could you could have inverse entanglement also zero one and one zero so and this is possible like when you generate particles of opposite spins and so the entanglement is opposite correlation so if you observe one and you see a zero that means the other one is collapsing into one at the same time and this they have shown happening across distances or 130 kilometers and so on on earth they've shown it working in space and things like that to ground, to earth. But distance is sometimes a problem, I believe, to propagate the light and to actually receive it on the other end. And then you can have multiple entangled photons as well. So if there are four qubits that entangle directly, right at like this. But you can have a hybrid combination of this entanglement for multiple qubits. So how do you create an entangled qubit? You apply the Hadamard first, right? Hadamard is the reflection we just talked about. So when you apply the Hadamard, let's say you have this, you have two qubits and you apply the Hadamard. What's happening let's say is you apply it to only one of the qubits so let's say we apply to the first cube right so then the zero is going to expand into the 45 degree direction right so it'll be one over root of zero and one over The lip here got mute. Oh, got mute? Now you're fine. We can hear you. Yeah, so you apply the Sadamard transformation to one of the qubits, and then essentially expanding one of the bits in the 45-degree direction. And you keep doing that, but holding the other bit as it is. So when you do that, the ones became like mine had the minus one over root twos. And then if these probabilities are all equal, the minuses cancel. And then you're just left with, say, this one over the zeros combining and the one zeros combining but the zero one is canceling with another instance of the zero one if these gamma gamma one equals gamma two and then gamma four equals gamma three and so you end up with this kind of a result. But you really, when you saw, when you wanted entanglement, we wanted this to be a one. So when you do that, to do that, you apply the CNOT key. So CNOT key says, if the control bit is a one, I'm gonna flip. So this is a control bit, and when it is a one i'm going to flip so this is a this is a control bit and when it is a one it's going to flip so you apply the c naught to this system and then you get this so applying the harder mark followed by the c naught creates an entangled state and then that is used a lot And then that is used a lot in quantum processing. So you apply these kinds of transformations repeatedly and the probabilities get refined during processing and the higher probability state to become more and more likely and provide a good solution. And you can also do hybrid solutions. You can set up the problem for the quantum processor, let it do some stuff, make a measurement. Then you can set up a different modified problem for the quantum processor and then keep doing this in an iterative fashion. And there is a famous algorithm called Shor's algorithm for factorization, which tries to find the period of a function in the first part classically, and then applies what's called a quantum Fourier transform, which utilizes the Hardemard gates multiple times, followed by additional transformations, and to get speed up in the quantum realm. So you can look at the Wikipedia page for it. You'll see a circuit structure very and you'll see a whole bunch of horizontal lines. Each horizontal line is a qubit and then you can put them through gates and things like that and out comes the final answer. So with quantum search you know you want work on these qubits, but you want to find, you want to target the search in a particular direction. And the key technique is called amplitude magnification. You want to amplify what could be more important. So I'm applying this currently to, say, wireless networking. And so if I want to give a node that has to transmit more importance, I'll apply this transformation, what's called an oracle that tries to focus on that particular state that's more important. And then we do a reflection. So this algorithm is called Brewer's algorithm. Let's say you have n items, and each one has the state xi, and we are searching for one of the items, i equals k. So we can create a quantum state, which is superposition of states of all of these n items, and you get this kind of an equation. So initially, all these states are equally likely. And so, you know, when this amplitude will be one over square root of n, right, because the probabilities are one over n, so the amplitude is one over square root of n. So now what you're searching for is inside the wave function with an amplitude of one over square root of n. Now what you do is you apply what's called an oracle function such that it changes the sign of the amplitude for this and leaving the other ones unchanged. So all the other states remain with probability one over square root of n, but this particular Xk has an amplitude now of minus one over square root of n. Then what you do is you reflect with respect to the side, and this results in an enhanced amplitude for Xk. And then you keep doing this again and again. You start improving the probabilities for this while the other probabilities reduce. And we'll see exactly why that happens. First, let's understand what's reflection. Reflection is defined as this equation. And let's see what happens if you size one zero and you try to apply it to itself so when you do this this is the cat and this is the bra when you applied one next to the other you get one zero zero zero right and you do twice that minus i so twice this matrix minus the identity matrix and you get one zero zero minus one so you apply this let's say on one zero and you'll still get one zero because zero minus one acting on one zero will give you a zero and one zero acting on a one zero gives you a one zero. So under this reflection, based on this psi, one zero remains unchanged. But if you apply to zero one, right, then zero one reflects and becomes zero minus one. So if zero one was pointing in the positive y direction, now it'll point to the negative y direction. But if this guy, one zero is pointing in the positive x direction, it'll point to the negative y direction but if this guy one zero is pointing in the positive x direction it remains the same so you can see that uh you know the reflection transform uh when you say reflection by psi uh with respect to psi if you apply it to psi it shouldn't change right like when you saw earlier, we were reflecting along the, with respect to the X axis. And if you already on X axis, you don't shift. So that's what's happening. You can see if you change psi to zero one, the same thing happens. When you do the psi, on this, get the bra, you end up getting minus one zero. So when you apply minus one zero to zero one to minus one zero to one zero you get a minus one zero but when you apply to a zero one it remains unchanged so you can see that you know now one doesn't, but zero is getting reflected with respect to one. In general, now, let's say you apply this reflection transform to psi itself. What happens is you have this bracket here, but this is a unitary matrix. So it's equal to one. and then you get two psi minus psi you can sign so applying the reflection on itself doesn't change it but what if it's orthogonal what if there's a wave function that's orthogonal to this and you apply it then you see that this inner product is zero, and then you get them, and you're applying this on phi. And so you get this times phi, and then identity times phi, but you know this inner product is zero, so you get just minus phi. So phi gets reflected, just like we saw one zero getting reflected earlier, but now this is more general, psi could be any direction. And now for any general phi that you act upon, now you look at this reflection transform, what is it doing? There's an inner product here, this psi acting on phi minus phi. What is this doing? This is making phi go go negative the totally opposite direction but because we want the reflection to be with respect to psi we're having this additional term what is this this is the component of phi in the direction of psi right so and you add that twice so you reinforce it back because you made it negative. Let's say you had a cos theta, you made it minus cos theta, and then you add a two cos theta, and so it becomes plus cos theta back again, right? So what happens is when you do this, the component of phi along psi remains unchanged. But the other portion, the sine, has become become negative and so you have reflected the component of Phi that's orthogonal to Psi so thus you know this this this reflection transform will reflect with respect to Psi anything that you apply like I said when you apply you applying these matrices on these qubits or a transformed version of these qubits. So now let's go back to what we said in the quantum search. We first will do this transformation where you apply the oracle function which flips only this guy to minus 1 over 10. And then you do a reflection of respect to psi but you know now what reflection means but what does the math look like so the oracle transform what does it do it's making xk minus 1 over 10 right so what so that can be written as subtract you know because you had psi had 1 over root 10 and when you subtract minus two over root n, then x case component is minus root n, but all the others are still remain as plus one over 10. So the oracle transformation can be represented as this. And then the reflection transform is like this. And we already saw what reflection happening on psi is, and it just produces a side To side minus side. These are the two terms coming from Italy, but then there's also the this reflection acting on this part minus 2 over root n X key and when you do that, there's the side acting on X key and you get a 1 over root n and There's a psi acting on xk and you get a 1 over root n and there's a 2 over root n acting on this xk when you do the math you finally end up with a minus 1 over 1 minus 4 over n and then 2 over root n xk. Where did this minus 4 over n come from? This is because psi xk is 1 over root n and then you already had another root n and then there was this minus 2. So all of this give you a minus 4 divided by n. Now psi still contains xk. So that is a 1 over root n times 4. So xk is amplitude y in 1 minus 4, 4 over n into 1 over root n plus 2 over 10. And if you look at this, this is approximately 3 divided by root n. But the other states now have reduced in amplitude. They used to be 1 over root n and now it's 1 minus 4 over n to 1 over 10. So xk has undergone amplitude magnification. And then if you repeat this multiple times, then you are very likely to select something with a very high probability. So the way I'm doing this, say, for network access is if somebody, if some node has higher favorability, I would say the link conditions are better, then you apply the Oracle transform for that one so that you keep shuffling around the probabilities and then you can pick any one of them to actually transfer. So the process is applying this oracle to actually flip you know the probability for one of them and then do the reflection. And so you're doing amplitude magnification, and that helps in finding what you want to find. So that's how searches are done. And then, so these kinds of things are basically done with the sequence of gates. And typically, these are called, these are the quantum computers that IBM, Intel, Google put out. They have, you know, a few tens of qubits. Now there's another class of quantum computers called annealing based quantum computers which D-Wave works on. And those are slightly different. There you don't have, you can't, you don't synthesize any, you don't have the ability to synthesize any kind of sequence of gates and things like that, which the Intel IBM quantum computers do. But what you have is they are in a matrix, just like a GPU kind of thing, all these processors are like all in a mesh, closely connected, and then you can operate with your neighbors and things like that. So it's the lattice of 2048 superconducting devices, and it's chilled close to absolute zero. And you model the problem such that you search for the lowest energy point in your landscape. such that you search for the lowest energy point in your landscape. So now what you do is you're trying to find this lowest energy state, you're searching for something in that space, and you're allowing all of these bits to interact with each other, but you allow the neighbors to interact and so on so sort of a mesh where all these cubits interacting with their respective neighbors and then you evolve it over time to find the answer so and you have what are called quantum processing units and quantum machine instructions and you can submit this quantum machine instructions to the quantum processing units and then they you know evolve the system one of the examples that we talk about is quadratic and constrained binary optimization we're trying to find the states of all of the qubits such that the energy is minimized. So you have these weights corresponding to all of these variables and you have a function and you want to assign values to the state such that this function has the lowest energy. So here's an example. So there are four nodes and they could could be self loops so if you say i'll pick zero then the energy goes up by 3.4 or to reduce the energy so you'll say hey i'm not going to pick zero because uh you know this the coefficient in front of it is 3.4 but i'll pick three hey that's negative so let me pick that uh so let me drop all of them. And let me just pick this. OK, maybe that's my lowest energy state. I just have third bit assigned to 1 and 0, 0, 0. But no, hey, there is also coupling between these bits. Like 0 and 1 are coupled. 0 and 2 are coupled. And there's energy associated with that. But we are trying to minimize the energy, right? So maybe we pick the ones that are negative. So we could say, let's pick two also because two and three are negatively coupled. Hey, but if you pick two, then okay, I'm increasing, reducing the energy by minus 3.22. But let me see if, you know, adding two is makes worse. No, actually fine, I'm fine. Because two is 2.1 and the coupling is more negative so it's okay to add two but is it okay to add one uh look one is if you add one it has a self coupling of 4.5 and then combined with two is another 4.5 and one three is another 4.5 you would just increase the energy a lot so you wouldn't bother to add one what about zero you add zero zeros couplings are also um highly positive there's a negative part but there are more positive parts that over uh override the negative so at the end you'll say okay i think my final assignment is two gets a one three gets a one and zero and one gets zero that's's what the d wave solves and finds the final energy is minus 3.52 which is minus 2.4 plus 2.1 so you're at minus 0.3 when you just do two and three and then you take the coupling between two and three is minus three point two two so that's minus 3.52 that's the energy of the system hey dilip can you ask a question yeah i have some basic questions very basic questions uh so what is qubit like very layman's term if you could explain me what is qubit so uh essentially uh think of that photon right right? Or in a superposition of states, and you're allowing it to be in a supposition of states. You saw the Hadamard Gate, right? Which actually takes it into an entangled kind of form. So it rotates it. actually takes it into an entangled kind of form. So it rotates it. And so, you know, if you had measured it and say it was actually in a state zero, by putting it through the hard MR gate, you actually end up in a superposition. That you can manipulate. So what you do is you end up utilizing the superposition. And let's say you have multiple photons, you have them interacting with each other. If they are all in a state of superposition, you allow them to continue interacting with each other in quantum jobs, then you make a measurement. If you do make a measurement, you can still apply Hadamard gates and then things like that and go back to kind of cross-coupled states and things like that to actually work with these qubits again in the quantum realm. But essentially, a qubit isbit is saying hey i may be either in state zero or state one but um you know and these are the probabilities that i may be in and so in software if you try to simulate this what you will say is um you know i have a head or a tail you know I have head or a tail but I have probabilities associated with the head and the tail and you represent let's say adjacent object with head and tail and the probabilities associated with them and that you will call as a cube. I see. So in software you would have just said head or tail but if you try to write a qubit you will say I have two possibilities for it, head and tail, and these are the amplitudes for it, and the squares are the probabilities. So let me just define that object. And then when you try to implement a quantum algorithm, you manipulate with these quantum data structures repeatedly. And you can apply these matrices and things like that. Then you can make a measurement all in software you can just do this in classically on a classical computer but just represent them in this form i see and so quantum search is basically search for that qubit state one any of the qubit state right are you trying to search for some particular item something that's You're trying to search for some particular item, something that's higher, you know, more important to you, or you're trying to find something that's more highly probable, but you essentially, you have to apply applying the Oracle transform to a system to keep trying maybe different variations, different items to see which ones are important and then amplify them. But your external input may say, hey, this is what I want to amplify. For example, like I was saying, what I'm trying to do with network access is I want to allow access to a network, to a node, which has a better link condition. So when I find that, then I work with a quantum state, but I amplify the state of that particular node because it has a higher link condition so that if I make a measurement most more likely than not I will pick that particular node and allow it to transmit so yeah so what is the oracle function or oracle transform if we other than can you try to define it other than non-mathematical terms? Like, I mean, the mathematical... So the, so the, the oracle tries to differentiate that particular state, you know, that minus xk, you know, xk became minus xk, right? So when you try to do this reflection with respect to, in a particular direction, because all the others did not change, when you reflect, they will all go somewhere, but the one that is minus actually flips back with a stronger force and reinforces itself in its original direction and therefore it undergoes an amplitude magnification so you flip it and then you reflect and then it ends up having a stronger amplitude but as the others you know go down in amplitude after the reflection yeah that helps uh understand more thank you very much yeah so i'm almost to the end um so yeah there was those two things that uh the oracle followed by the uh earlier here let's one more example here if we add one more Here, let's one more example here. If we add one more qubit to this system, again, you'll see that it decides to do 10111 and you can work through the math and basically doesn't allow 14 to go on. But everything else, if you add up, say one is rejected, right right so you add this and this you'll get plus 0.7 right and you've rejected a one right but one is rejected so take 3.4 minus 2 minus two, combine that with this guy, this guy, this and this, you'll end up having minus 18.12. So adding up all of these guys, getting you minus 18.82, and then this guy you're giving up plus 0.7. So you end up as this is the lowest energy in the system. So, but note that this kind of computer is not what we were talking about earlier. It's only allowing some interactions to progress between qubits locally, because it's like a mesh of qubits that are interacting with each other. But you can, you know, change the weights of the correlations between these qubits to and then allow it to converge. And where is it useful? For example, they try to do map coloring with this or, you know, to figure out a solution to color different regions by assignment of states to respect to color for every region and map and things like that. And then it settles down to something that doesn't have any conflict or minimal conflict and so on. But this is more like if you've heard of annealing and things like that optimization, this is an approximate solution. So what D-Wave tries to do is not like a perfect classical algorithm. The IBM, Intel, Google computers try to do those classical things. You have a fixed algorithm, you know exactly what you get get here it could be an approximate thing and let it settle down to some minimum energy and you take that as your answer you go with this is this so delete this is is this something like what we do in like machine learning where we try to you know reduce the error or something like that to a certain degree of inaccuracy? Yeah, yeah, you can think of it that way. But then, yeah, you have to have knowledge of correlation. So they think of it somewhat like a clustering problem, trying to partition and you're trying to, things that are getting strengthened are belonging to the same cluster and things that you know that are not strengthening things that are weakening both the opposite cluster kind of thing so it's trying to create a partitioning and so and then an allocation for the for the problem and then an allocation for the problem. So if you have an exact algorithm, you will go with like the IBM Intel Google kind of for computers to and build a sequence of gates and you write it as a sequence of matrices from left to right, the leftmost will be the last matrix operation that you performed. Whereas with the D-wave kind of thing, you're trying to kind of find a solution to a problem by mapping it to this kind of quadratic optimization. So these are called, these energy functions are called Hamiltonians also, and you're trying to find you know the minimum energy state of the system and so it comes from physics but then you translate that to an actual problem in computing and then let the quantum computer do the physics and give you the answer right for you so these are some books that are useful. The second one is probably the most useful for, and you can actually get a free PDF online. It's the most celebrated book in this area, Nielsen and Schwann, Quantum Computation and Quantum Information. The first and third are more physics related for those who are curious about how Schrodinger's equations work and things like that, if you're interested. And there are a lot of Wikipedia and online lectures from different universities, MIT, UC Berkeley and so on. And then D-Wave also had some documentation because it does a slightly different kind of quantum computing, more approximate quantum computing. So that may be interesting as well. And for me, I see this as part of a bigger scheme of things where we may have AI, ML, IoT, 5G, and think blockchain and so on. And 5G can allocate resources and networks, IoT systems can monitor and provide triggers for processing, and have blockchain systems executing smart contracts, recording events, but you can also have quantum-inspired algorithms as well executing in virtualized infrastructure. So that's what's driving me to kind of, because I have to kind of look at future technology as well. So I'm trying to see how to integrate quantum inspired processing as well. So yeah, I was just walking you through my own journey in this, what I've been trying to learn. Hopefully, I was able to share something. If you have any questions. This is Amit, again, that was great. And actually, you kind of very nicely combined both the theoretical and the practical aspect. This was very nice. Thank you. So just, Dilip. Can you hear me? Yeah, yeah. So we are doing like a quantum searches in your example. So you are constantly taking measurement of all the nodes and just doing a quantum search for a best node and trying to route the traffic through that node. Is that the concept? Oh, oh what i'm trying to do yeah oh yeah so i'm trying to apply it to networking for example uh and maybe you know uh all the different nodes uh are different possibilities so uh of who would uh transfer next so I have to pick one of the states or to say, with whom I'm gonna pick next to transfer. So I'll try to apply Oracle transforms to, when nodes are more favorable in terms of, in terms of getting access to the network, because their link conditions are better. The other thing you can look at if you're talking about routing could be, hey, which path is less congested? And you could apply an oracle transform to that less congested path and make it more favorable and apply quantum algorithm to select the best route so so you can keep applying it to different types of problems yeah i see so this will be i think very beneficial for network slicing type use cases right yeah yeah yeah definitely and uh not only in networks i mean mean, so people have started, see, the thing is, you know, we don't have to actually run these things on quantum computers. We might actually, by creating some quantum algorithm, quantum-inspired algorithm, you could evaluate, you know, a superposition of states. But what I think we have to do is not let it just run completely to the end because uh you know let's say we create uh two raised to n threads for each of the possibilities and let them evaluate each one of them then you know you didn't gain anything right because you instead of let's say you started with some random initial state to find what the answer is let's say you tried all possible initial states and you have threads running all of them concurrently. And then you find which one is the best one. That's like brute force. So what you have to do is you start exploring. But at some point, you have to take a call. Okay, I'm going to stop searching along these paths. Just like in how a computer plays a chess game right it's nice to evaluate different things but it proves that different parts so we have to if you think quantum inspired you're thinking of a superposition of states you start uh you know uh narrowing down and then again try to go quantum and then again come back and narrow down image eventually you probably will be picking the one you'll be finding the one that you're looking for so and hopefully by doing that you will get a faster speed up even on a classical computer just by thinking on quantum in how we try to solve the problem and and people have tried to apply to recommendation engines also trying to explore different possibilities but creating a data structure which is as if it's a superposition of stage exploring what we should do is you know pause and then you know that hybrid thing of classical versus quantum can keep doing that and you know when pause and then, you know, that hybrid thing of classical versus quantum, you should keep doing that. And, you know, when you think of parallel computation, you have this computation, this communication, and, you know, you have this interleaved phases of computation, communication, we should, when you do that computation, you do the quantum inspired, and then you have a phase of communication to kind of reconcile your results, to try to decide how to focus, you know, your energies on the next stage of computation. I think if we try to design algorithms that way, maybe we'll get very interesting results, even classically, but once the quantum computers can be used for that, you might get a higher performance as well. So when you observe, right, your wave function collapse and it becomes particle, then you try to entangle the particle becomes wave again, is that the concept? It remains, you know, it's neither a wave nor a particle but you know you can call it a you know our chandra and i had a professor at item at our school which was a politician would call it a varico but you know like like you said you know when it goes through the polarizer, and it's still a wave function coming out in the x direction. But it has a definite state associated. But yeah, you're right. And then you can apply the, you can create an entangled state, if you like, and things like that after measurement and and so then you go back into the quantum state uh of superposition of these qubits you have fun with it and then again you take a measurement like you just said yeah and that can be fun we can try to some interesting competition yeah so when you try to create an entangle how you're going to save that information what kind of data structure you will use to save that entangled like superposition information? When we write a computer algorithm, we can actually save it in the sense, you know, it's a data structure in the computer with different probabilities. But in an actual quantum computer, you can't see it. If you make a measurement, it will collapse. So actually you have an advantage. If you write a program, which is quantum inspired, you actually can see the probabilities because you're evolving the probabilities as you go along. Because you have a data structure to represent the entangled state. But the actual quantum computer, you're at the mercy of the physics. And the probabilities are evolving internally all you can do is take a measurement and see what it provides as an answer. Nice, this is the software level okay. Yeah so you could do completely in software then you have access to everything but when you abstract the quantum computer out the actual physics part of it out you don't have access to the actual probabilities of switching the states. You know the states that it could be possibly in, but you don't know the probabilities of switching. And it'll collapse to one of them. Okay. Any other questions? Yeah, so I have one question. So what kind of physical systems you use for the making these qubits like these two photon states or two quantum states? Yeah, so they use this superconducting systems, Yeah, so they use this superconducting system, supercooled, almost zero degree Kelvin kind of thing. That's for the D-wave? Yeah, all the computers are like that. of operating at very low noise levels. It has to be super cool so that noise is extremely low so that the probabilities are preserved and things like that. And then you use these polarizers and beam splitters to kind of do this gate transformation, such as the Hadamard gate and things like that. And so it's a lot of superconductivity physics that's going on. And Asif can probably tell you more about how these physical or how the physics works but um yeah but what happens is that okay what the physicists will do is they'll say okay look this is what you this kind of operation is what you want i will do it in my quantum computer and this is my result uh so you know you don't have to worry about it like you know you saw the quantum machine instruction right all you have to say is, you have to issue the instruction and internally the physics will execute that instruction on these photons. Thank you. Thank you for the nice talk. Yeah, one thing to add from a physicist perspective. See, the quantum computing theory, like Dilip explained, is ahead of the physics. It's very well developed. There are remarkable things that are arising. It's becoming popular. We can use languages to do quantum computing, at least simulating it on ordinary computers. Physics will take a little bit of our time to catch up. Just two, three days ago on June 25th, we had a fundamental milestone in this. I don't know, some of you may have heard about the CubeSat. There's a satellite, and on that satellite, for the first time, quantum entanglement was actually observed. And it's quite exciting actually for the physicist community. Oh, okay. I didn't know that. Thanks. Dilip, one last question. Yeah. How heavy of computation it is, right? Like on that's a node. Like you need a lot of computing power or software? Yeah, actually these systems really take a lot of energy. But hopefully they can solve a higher dimensional problem much faster and therefore it would be worth it you know to execute all those on these computers so in terms of 5g network for example can you implement it at the edge device edge edge nodes as well not at the edge device oh no no no nowhere close to that right because these are this will be some super cool things sitting in some uh specialized locations somewhere so what you have to do is you have to send all uh you set up the problem send it to the quantum computer, and ask it to give an answer. It is almost like the olden days we used to put punch cards in the mainframe. There'll be a bit of latency to access this thing, so it better solve this higher dimensional problem for you. But you know that there is this part, but there's also this part of being quantum resistant, there is this this part but there's also this part of uh being quantum resistant which is uh you know if you do all your uh computation just be quantum resistant so a quantum computer could do some prime factorization and break your photography and so they say uh they suggest using sha 5512 from now on sha-3-512 for your hashing so that you know your quantum computer you know targeted you need about one-third the qubits to target a hash and see if you want to target a 256-bit hash you need about 85.33 qubits about 86 qubits and you're already at like 70 qubits so 256 is one number so but with 512 you need about 171 right so qubits so that may still be a far a long time to go so sha 3 5 keeps, whatever you're doing classically secure prevents a quantum computer from breaking. So you can continue doing your work classically, just make sure your encryption happens in a higher dimension such that, or hashing happens in a higher dimension so that you know quantum computer even with its potential will not break and then you don't have to worry about quantum computers but if you want to use quantum computers then you would do this you would try to map your problem to a quantum computer send it send qmi to the quantum computer let it execute and then you could also try to do quantum inspired software as well. Okay, excellent, thank you. Any more questions guys? I have just, this is Abhijit again, I have just one last question. So those physical quantum machines, right, the physical, the super cool cryogenic kind of machines, right, they're, these gates you talked about, right, the CNOT and the Hadard gates, are those, so if suppose we have to do it in the physical machine, not using the classical computers with the quantum inspired algorithms, then are those gates built into those machines? I'm just trying to visualize what those machines, I mean, I understand, of course, there are all the pipes moving around with the you know cooling and all those things happening but what is that exactly they have this kind of polarizer it's like a green uh pyramidal thing and it's say uh set at 45 degrees uh angle to the photons that are coming in and so that causes you know the bell states the plus and minus states you know that for plus and minus 45 degrees so whenever you ask for it then it will produce photons put it to the polarizer and the output photons would actually be in this in these bell states that can be subsequently processed and things like that. Until then, you're not doing anything until you ask. So based on the problem that you're going to solve, it has to be kind of configured that way? Yeah, yeah, yeah. Oh, okay, okay. So the equivalent of qubits, the number of qubits and all you have to configure it that way basically. Yeah, yeah. But what I'm saying is that maybe see what quantum algorithms are trying to do and see if you can even classically have fun with it right without even having to talk to quantum computer but all of these things all of these computers are available in the cloud and get access to them as well and try out some fun stuff and there are simulators available as well okay like google cloud are they available in google cloud yeah should be i haven't uh tried it yeah maybe maybe ask if you know i don't know i think it's a service that google exposed i believe the d wave and-Wave and so forth, right? No, D-Wave, yeah. D-Wave exposes its own service. But yeah, Google, all of them have it on their respective clouds. So you have to connect to the cloud and then ask. And usually though, if you're in academia, you have more resources, but if you're not, I think they give you very limited resources like the IBM quantum computer will give you a little bit of time, but it's still adequate to kind of fool around with it. But then after that, I think you're paying for it. And there's this whole emerging field of quantum machine learning. So, Asif, you want to throw some light on it? That would be a big topic, perhaps. There's a very interesting intersection between quantum. Actually, all of these things are merging. The whole mathematics behind machine learning is so close to physics and quantum is physics. So there's a gradual convergence now of all these things. Yeah, yeah. Yeah, and it's fun and it's kind of... Okay, if enough people are interested, I would like to talk about quantum machine learning. It's a little bit far out there at this moment, a little bit away, but it's one of those things that you dream of today, you build a theory, by the time it becomes practical or real, it's another 10, 15 years. Yeah, it should be fun. We should explore. Yeah, we should explore fun. We should explore. Yeah, we should explore. Dilip, hey, thanks a lot. This was a most... Thank you. Just the right... Yeah, you're welcome. ...practice and actual reality here. This is... I wish the audience could see you if your video worked. Oh, yeah. Sorry about that. I don't know what the problem was. I wish the audience could see you if your video worked. Oh, yeah. Sorry about that. I don't know what the problem was. Asif put a photo over there. I still look like that. Yes. In the video that we put advertising this talk. All right, guys. Thanks for coming. Thank you. Thank you. Thank you, Asif. Bye. Well, I didn't think that you'd be thanks for being here. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Have a good day. Thanks. Thank you. Have a good day. Thanks. Thank you. Have a good day. Bye.