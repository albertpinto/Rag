 So, alright guys, the best way to start with Python is as simple as that. Just start. So we are going to start with this and this notebook again, I'll post to our portal. Should we say intro to Python? And we'll code along as we develop our ideas. Are you able to see my screen? Yes. Yes. See, Asif, one quick question. Today as we're going through this, do you prefer that we actually start the same? Is that a Jupyter book that we should open and follow through or you want us to look and follow through? your machine also start a jupiter notebook do that do that i'll go slow enough and i'll be explaining enough that if you create your own notebook then you you'll benefit more otherwise we are all busy professions you won't get time so so So guys, we get started. Have you all started a notebook? I have many open. Many open, good. So I assume that at this moment you have started. So guys, as you write your code in Jupyter, and I would suggest in the beginning start with jupiter and then graduate to once you become a little bit familiar i want to get you started with pi torch i'm not peter sorry by charm or eclipse spider both of these are full-fledged ids and they make your life a lot easier when it comes to writing code so one quick question there as if when we install anaconda it come by default it comes with spider right yes spider is there and Jupiter Jupiter lab all of these are there you can use spider see here's the thing if you look at the mindshare in this community, in the AI community, it is broadly divided between writing all the notebooks and experimentations in Jupyter, Jupyter Notebook or Jupyter Labs, or Colab. Google's Colab is essentially the same thing. And writing longer sections of code in PyCharm. PyCharm. PyCharm, okay. PyCharm is by far the leading. After that comes all the rest of them, Eclipse, PyDev, and then the Visual Studio Code and so on and so forth. Now, people who love Java and Eclipse, they actually find it easier to just add the Python plugin to their already existing Eclipse environment and start coding. But then Eclipse has a longer learning curve. If you're already familiar with Eclipse, then you are a great place. If not, PyCharm has very little learning curve. Quickly, you can get started. And I'll do a session on PyCharm also. Let's keep it for next week, weekend. I'll do a session in which I walk you guys through using PyCharm. Okay. All right, guys. So in any programming language, if you think about it, these languages, if you are thinking from first principles, what you had is you need a place in so-called memory of a computer, random access memory of a computer, to store a value. Because let us say that you try to do X plus Y. You want the machine to compute 1,197 plus some other large number, Y p, you know, 2 million 3000 something something. And you can't do it by hand, you want the computer to do it. A computer is essentially made up of three things, four things actually, roughly speaking, in a simplified way. And maybe I should draw this out because that I find that in a way it makes it easier to get a handle on Python quickly I'll share a different screen guys Are you guys seeing my writing screen? is we will use this so let me give it a title python so even before we do python i just want to set a perspective straight and most of us know this but we tend to forget a computer has just three large units you have the CPU which can do arithmetic and logic logic is and or operations etc and these are logical operations so for, if it is raining and if it is daytime, then I may not go to Starbucks. That would be an example of a logical thing. Arithmetic would be three plus seven and it has some register. Then you have memory, memory, and then there is storage that you just mark it as storage which these days are either SSD or hard disk HDD some form of hard disk storage or it can be cloud storage what not are different forms of storage so when you think of a machine, don't think of it as this fancy semiconductor monsters thing. For a moment, the old old way when these machines came about, what used to happen is this memory used to be or you would save something in memory or to do these things by literally have a solenoid with a core, right? Or with a solenoid is an electromagnet, soft electromagnetic material and with electricity. And when you will charge it up, it would get charged. It would have not sunk and so forth. So you would say that it has a positive state one, otherwise it could have zero and you could have a lot of these solenoids and things like that little bits. And then you could do your arithmetic logic unit in the early days. It used to be vacuum tube transistors, something like this. You would do that. So go back to the very basics. Think of these as very physical things and it will make it easy for you to understand programming so suppose you want to do something as simple as z is equal to x plus y right so let us say that x is equal to 17, y is equal to 34. And let's say that adding these two is not so easy. And you want to compute z, which is equal to x plus y. So we will do this basic algebra using machines. So what do you need to do? You need to take this 17 and put it somewhere. It needs to be in the memory. So in memory, what you would do is you would take a certain area, certain amount of space, certain number of these bits, each of these are bits and so on. You would reserve a few of these to store the value 17 in binary notation, whatever its binary notation is. So once you store it, what you see is logically speaking, you have taken allocated yourself a box. Here is a box and this box you have put 17 inside that box, the value inside the box right this is the value and this box has a name you want to give it a name let's say that this is like a very much like your mailbox a parcel when you send a parcel by um the postal service what do you do you put some stamps here and you put an address you put a name to that you say it is going to my friend X. This is X. Or when you do packaging, when you pack your house up or you pack some things, you put things in a box and you label the box. So X is the label or name. So what you do is you say that I will take 17, put it in a box, and then give it a name. That is what it means to say in programming when you say x is 17, you say that you have taken the number 17, found a box appropriate for it, put it in the box, and the name of the box is x. So this is the real meaning. But when we say So, this is the real meaning, but when we say the people have created a bit of a jargon, they say the word it's a variable. And the reason they say variable is it is possible for you to take 17 out of the box and put something entirely different in that box. So the box will still be labeled X, but something, some other value is sitting in there. And if you allow for the values to change different things to be put in the box, it's a variable. If you don't allow it for it, if you put something and it remains that it is a constant. So that is where the word variable and constant comes from essentially. So whenever you read code, one simple suggestion is whenever you read statements like this, you say is a statement doing something. Always read it not left to right, which is a tendency to do as English speaking people, but to read it right to left. When you read code from right to left, what you're saying is, think of this sentence, take 17 and this equal to has no meaning. It's just a symbol that people have used in programming. It sort of makes sense. But if you think what you're doing physically is you're taking 17, creating a box named X and putting 17 into the box. So let me write it in so many words. You take 17, create a box, label it X and put 17 inside it. So this is what you should, what is logically there you you often say things like assign you the way people tend to say this statement is a sign X the value 17 it's very cryptic because if you read it as an outsider you say what is X and 17 I can understand what does it mean to assign a value so this is this thing this is what is meant when you say assign the value 17 are we together guys So far, so this is called an assignment operation. Operation So now we do going back to our fundamental problem we are trying to do x plus y is equal to 17. So what will you do, you will do the same thing. y is equal to 34. So once again, we will think of it as taking 34, getting a box labeled y and putting 34 inside it. So suppose you do that, right? What will happen is you create x, you create y, and then when you do z is equal to this logical operation, these two things are copied literally as X and as Y in the so-called register of the computer. Computer has some extremely expensive, very small amount of memory built in. Those are the cache, L1, L2, L3 cache, and the registers. They're literally called the registers onto which all the operations are done. So you would load this data onto the registers and then you would do the arithmetic logic operation, in this case, the arithmetic operation. So you add the two registers and the accumulated result is 51. Now you need to store 51 somewhere. Once again, what you're seeing is go create a box called Z, Z, label Z, and inside it go store the value because the moment you compute it in the register, you will need a place to store it. So go store it in a variable called 50, in a variable called Z, store the result of it. And computers move like that. All they do is, and if you think in terms of registers and arithmetic logic unit, you'll realize that all programming languages are fancy ways. They're nice ways to give you a convenient ways to help you load things into registers and do arithmetic logic unit operations on them. Right? The one common operation that you do in every language is you get boxes and you put values in it. You assign them a variable, a label. And they're often called variables. In some languages like C, C++, you sort of distinguish between a variable and a constant in Fortran and so forth. In Python, you don't just python is a much simpler language you when you say x is equal to 17 you take 17 and put it in a box now there are two kinds of languages one is called statically typed languages and one is called dynamically one are called dynamically typed language there's a difference between the two. See, if you just have a general purpose box, every time you want to store something, you can give yourself a general purpose box. Think of it as just one of those, you went to Home Depot and you got some brown boxes for packing. Then you say that you're doing something called scripting or those variables in that box you can store anything. You can store cookies or you can store shoes and it's terrible if after storing shoes you want to store cookies, something like that. But nonetheless, you have the freedom to store whatever you want in the brown box these languages are called dynamic languages right or scripting languages and so forth python is like that it puts no restriction once you have created a box named x what you assign when you say assign a value x to assign a value to x it means putting a value inside x now what you put is can be a number it could be a shoe it could be a string it could be just about anything that is something to remember now if you are familiar with that's another kind of languages for example if you are familiar with uh so r by the way is also in that category but if you are familiar with a language like c plus plus and java in java or c plus plus you can't do that you have to be more particular for statically type language sorry let me move it here for statically right languages Right. Languages. So when you say X, you will have to say int X is equal to 17. This would be a syntax in C C plus plus Java. Right. Java, right? And the Python syntax would be dynamic, dynamic kind of language that would be Python, R or JavaScript and so forth. You would just say X is equal to 17 or the equal, this symbol is not really equal to its assignment symbol and it differs from language to language for example in r you would say like this and it sort of makes the meaning in my mind much clearer that you take 17 and you assigning it or putting it inside a box named x equal to might make you feel it is x is equal to x is a box it can't be equal to anything but you can put a value inside it now there are advantages and disadvantages between these two what happens is when you use statically typed language it is strict it doesn't give you much flexibility so the amount of code you write tends to be a bit longer. These languages are a bit low level, they are verbose. That's the downside. The upside is because you are declaring or what the type of a box is, you can't make a mistake. You can never put a string or a shoe inside a box that's meant for a number. Are we together? So you cannot do this, X is this, inside a box that's meant for a number. Are we together? So you cannot do this, X is this, and the next sentence you cannot do X is equal to a message. Or you cannot do X is equal to some shoe. So suppose you have some shoe lying around, you cannot do this. So the system will not let you do that are we together but in dynamic languages in dynamic languages it is perfectly okay to be able to do this message X is equal to some shoe. You can put just about this is okay in dynamic languages. Do you see the distinction guys between Python or between the dynamic languages and Python is one in that category and a statically typed language. Are we clear guys? So now the advantages and disadvantages. First is that if you have X you don't know its type in a dynamic language. It may have changed. You may have started out with something and it may have become something else. Something else may be there. So imagine not looking at a box, putting your hand inside it, expecting a cookie and a stinking shoe comes out. You wouldn't want to put it in your mouth. And that in a sense is the danger of dynamic languages. Dynamic languages are very simple to write. The code is more compact. You can do some things really interesting things with it so for example you can say i will take any kind of thing and do do an operation and things like that the statically type languages don't usually allow that level of flexibility and not only that, the compiler has no clue. If you do this, in a statically typed language, a compiler would come and say, compiler will put those cross marks. The compiler that translates your code into an executable will go and flag it out. It said, no, this code is not acceptable. It's not kosher. On the other hand, a compiler will be silent because there is no compilation in a dynamic language. It is just in time compilation or no compilation at all. Things are executed statement by statement as it is. So what happens is you discover, if you make mistakes with types and so forth. So for example suppose x has become a shoe and then you do y x plus y z is equal to x plus y you realize that there is and let's say that y remains 7 y remains 34 then you realize that, this computation cannot be done. How do you add a shoe to 34? So the thing is you will have a failure at runtime. This is an important thing to remember about dynamic languages, especially a language like Python. So Python, people have a lot of frustration sometimes with the debugging or the code. They feel it works, it looks logically correct. And then when you run it, you know that it's a mistake. The way you avoid it, so how do you have the best of the fact that a static languages, the compiler will step in and help you, right? Prevent you from making mistakes. but the code is verbose in Python. The code is short elegant in some sense very clear. Satish Penmetsa, Ph.D.: Very easy to pick up, which is why I said we will be productive with Python in the in the in the better part of an hour today. And so it's very expressive as a language. today and so it's very expressive as a language scripting language is always very expressive the downside is downside is you lose the typing with dynamic typing the com there's no compiler that helps you overcome its limitations so there are two ways to overcome this two important ways that you should follow those important ways are one ways to write say for good Python. What you do is first is the very basic thing. Add type hinting. People are realizing that, you find bugs when you run the code and then you realize that it failed. You can find bugs by adding type hinting. What does that mean? Don't just say x is equal to 17. And by the way, the type hinting is a new thing that most people in Python don't just say x is equal to 17 and by the way the type hinting is a new thing that most people in python don't use if you look at my code you will notice that i use type hinting quite heavily it is a good thing unfortunately most people don't use it so be warned that you may encounter most code without type hinting so what type hinting says is you can declare what it is int is equal to 17 have you noticed this if you have been reading through my code base have you seen a syntax like this you may if you go back look at the Python code you'll see a syntax like this. So what happens is that, remember that Python is a dynamic language. You can still do X is equal to a message. Something like this. What will happen is if you run this code, it will still fail at runtime at this. There is no compilation, but if you are using a smart id let's say you're using pycharm or you know pydev or any one of these ids this ids do the job of a compiler in other static type language they will immediately see that given that you have given the hint int this should not be allowed and they will put a warning or a error depending upon how you have configured your id telling you that you are making a mistake because you are declaring your intent that always you will store an integer in x so this is called type hinting type hinting is a very good thing since you guys are picking up python for the first time i want you to start out on the right foot do use type hinting it makes your code a little bit longer to write but it's worth it so sometimes you know in a statement like this you might not need type hinting because when you assign 17 to x it is implicit into x, it is implicit that x is an int. It is an integer. So here using it at this place might be an overkill. But there are situations where the intention is not so clear. So use it judiciously. If in doubt, use it. If it is very obvious what the type is, then don't use it. My rule, whenever you're declaring functions, always use it. So now we'll come to the second thing. We'll talk about functions. But before we talk about functions and when you guys write code, especially in Jupyter, functions will come much later. So we will keep it perhaps for another session. I will talk about basic constructs. I just have one big question. The type hinting, does it work on inside classes also, everywhere? Oh yes. A good idea will heavily use your type hinting. It's one of the things, type hinting was not used a lot, but if you look at the formal, the world-class libraries being written in Python now, they use type hinting a lot. So what did we say came around after 3.7 something? 3 plus or 2.7 didn't have it. Yeah, 2 dots. Since see, I don't think type printing existed in Python 2 series. It only existed in Python 3 series. I think fairly confidently I can say that, but I might be wrong. Anyone of you who has more knowledge in that can tell. That's what I mean. At least I never saw it in 2.2 series but i don't know about three much so that's why you know yeah use today you should use python 3 there's absolutely no reason to use python 2 unless you're maintaining code no but actually this is a very good one you pointed out yeah thanks i think it's a very important one actually but they're using using the typefitting in Python. So guys, stepping back, when you look at a programming language, believe it or not, there are only three constructs you need to make a language something called a Turing complete. As you know, Turing, of the Alan Turing fame, the guy who pretty much gave us computer science in the first computer. So one of his results was, but then later on we, for structured languages we can state it differently. It says that for a structured language to be able to do everything that any programming, any computer can do, that in other words a Turing machine can do. that in other words a Turing machine can do. Turing machine is a general purpose, hypothetical computer that in principle can solve every solvable problem. So to say, to be able to give instructions to a Turing machine, the language has to be expressive enough to have only three basic ingredients. Those three basic ingredients are, can you guess? One of them is statement. You know what we just use assignments and things like that. These are statements. You have to have the ability to write statements. So let me terms for a language, for a structured language to be complete in the Turing sense, complete. states, statements, conditions, and iteration. So statement is an example of statement is X is equal to 17 is the statement it's an assignment statement right or it could be y is equal to the value of some function fx right those are all statements what is a conditional so a conditional would be a statement like if it is raining raining, go out with an umbrella. Or more practically, if it is daytime, if daytime, temperature is likely to be, is equal to on average, let us say 70 degrees else temperature is equal to well at night I suppose temperature is much more likely to be 60 degrees I suppose this fairly well describes the average behavior in the Bay Area isn't it so that is assigning the value, the temperature, assigning a value of 70 to temperature if it is daytime or 60 to temperature if it is nighttime. Do you see that? So it is a branching, conditionals are branching. So in a flow diagram, it would be like you you based on this you go this way or that way making sense so far guys and the third thing you need is the ability 10 times do something. This is an example of iteration or while some condition is true, while some condition is true, is true, do something. The hope is you gradually make that you have something, you budge something so that eventually that condition will become false. Otherwise this loop or this iteration will go on forever. So guys, branching, loop and statements. These three are the pillars of a structured language. Any language that has only these three things is actually Turing complete. It can do everything that any other language can do. So let us take some examples and think about it. When you just write HTML do you think it is Turing complete or it is a complete language anybody no and why is it not um i see it as a markup language there are no concepts of um for loops exactly yes it is it is has statements, but it has no conditions and no for loops. No iterations. Right. Let us look at SQL. Most of you have done a plate with databases, a SQL, a SQL query or a SQL statement SQL. What does it have? It has statements. Right. What about Conditions. The SQL support if Where yes it's where yes, which is the same as if. Yeah. And what about iteration. No. It doesn't directly support it unless you are doing some enhanced version of SQL, like for example, a PL SQL or something like that, then our stored procedures, then it becomes but otherwise you don't. So it is in other words, a data manipulation language and a data description language. But you don't traditionally think of it as a programming language unless you add these extra things but the moment you add these little extra things it immediately becomes a full-fledged a programming language so every database vendor has done that so you look at sql server microsoft's they will give you their own enhancements Microsoft, they will give you their own enhancements. So you can write stored procedures using that. If you are doing Oracle, you use PL, SQL and so forth. So all of these things give you some way to enhance it and make it a full programming language. Now, the reason I brought up this theoretical thing here is that two reasons. First is people often think it's a very simple language. I don't think it can do this or do that. No, Python has all three basics. Therefore, it can do everything that any other language can do. The other way also sometimes people say Python is a modern language that does everything better than some other language. That too is not true. Python, by the way, is not a modern language. It arose in the early 1990s. It's almost now 30 years old. So by no means modern, but it certainly got a lot of, very popular these days. Python and Java are the leading languages at this particular moment. Dominant share, it belongs to them. Both of these, Java is statically typed, Python is dynamically typed. JavaScript is rising and probably about to gain as much. So the territory will be shared by three major languages and other languages are climbing up the popularity ladder. So remember that when you pick a language, you're not picking a language based on whether it's more powerful. You're picking a language based on whether it is more appropriate to your work. So what happens is people who do operating system work, they have written the basic constructs for operating systems, like the locks, the semaphores, the schedulers, and so on and so forth, in C language, which is why you tend to see a lot of the operating system and systems code written in C because libraries exist that make it very easy for you to do that sort of deep multi-threaded code at a low level. So that is the reason you prefer C. One reason that you prefer anything else, for example, a lot of the middle tier code is often written in Java because there are tons of libraries. There is a ginormous ecosystem of Java libraries so that anything you want to do today is just gluing these libraries together and you can build an application in no time. Python, coming to Python, and R, and Julia, which is an emerging language. These three languages, they have made it a mission to focus. I mean, Java is, Python is a general purpose language, by the way. Even when you install Linux, your installer is written in Python and so on and so forth. Lots of Python scripts. But for data science, these three languages have become the favorite language. The oldest of them is R. R derives from S. S is one of the most well thought out languages. In fact, it was given a very prestigious price on the beauty and power of languages. I forget what it was from Bell Labs. It's a very elegant language. Any code, I mean, traditional, a lot of the work, if you have been doing data science or machine learning, you'll realize that if you can do it with R, you will do it in far fewer lines than any other language. It will just be one-liner, two-liners and so forth, very rich ecosystem of libraries. But then gradually people, as data science, AI became more popular, machine learning became more popular. More people wanted to learn it and a large number of students these days come with background in general purpose languages like Python and Java. So there was a trust to create libraries in these languages rather than have people learn a new language. So a lot of the libraries were rewritten or recreated in Python. And underneath that, see all of these behind all of these are the same old Fortran libraries, but nobody feels like learning Fortran these days, unless if you're in scientific computing. So over the Fortran and over the C these are layers, R and Python, they just form layers over it in some sense when it comes to data science, machine learning. So Python became popular and a lot of libraries were created in Python. The process is still going on for much of the outside deep neural networks. Generally R is more, is richer and the code is more elegant than with Python. But R again has a learning curve and people don't want a learning curve. They say, we know Python to do everything else. Why can't we use Python for this purpose also? So the Python libraries are more or less catching up for deep neural networks it is python first philosophy the code all the deep learning libraries pytorch and tensorflow the dominant libraries they are all written in c and c plus because those are high performance libraries nothing beats the performance those are high performance libraries. Nothing beats the performance, generally speaking, of Fortran. Then comes C and then comes C++. And then people are trying to create new languages these days, Go language and so on and so forth. And they're trying to have similar speeds. But I mean, the big king of the hill have always been Fortran C, C++. Java is very fast. It's beginning to catch up. For the non-UI stuff, it's beginning to catch up with C++ gradually. Python, on the other hand, is notoriously slow. It's a horrendously slow language. Why? It's an interpreted language. You have to use all sorts of hacks to make it fast. For example, you have to pre-compile it. You have to use all sorts of hacks to make it fast. For example, you have to precompile it, you have to use just-in-time compiler, you have to translate it into C and then compile and so forth. So those limitations remain with a interpreted language like Python. It can be hundreds of thousands of times slower than C or C++. And Fortran is of course incomparably slow. Nothing comes close to Fortran. So that, but we tend to write these deep learning libraries in C++ and the first bindings we create, we tend to do it in Python. Second comes R. So this has been the state of the art for a long time. Then has entered a third language, a really interesting concept. It said that, see, why are we writing the code fundamentally in C, C++ because it's faster there or Fortran because it's faster there. And then converting and then putting a layer of either R or Python on top of it. What if we created a language which was sort of like having having the cake and eating it too so there is a language on the block called julia new language with a much smaller ecosystem it will take a few years to mature but it's quite elegant and it's actually one of the things that i absolutely love about fight about julia is that if i want to write theta i don't have to create a variable called theta in english theta is equal to this i can literally encode embed the theta symbol the greek symbols and i just find that absolutely i suppose little features like that make us like languages i absolutely like uh julia for for that it It's just amazing. So Julia is a language that tries to be very expressive like R and Python, but at the same time have native performance of C, C++. And it has pretty much achieved that, but it's a young language, it's growing, smaller ecosystem where you can use Julia, you do use it where you can't well of course so anyway coming to python uh remember this that python is just when we use python libraries the reason we do it is because people have committed time and resources to making sure that for all the common tasks in ai we do have libraries in python and you can write it in very few lines of code we do have libraries in python and you can write it in very few lines of code i think a quick question um uh so and basically there's you may know about this language rust right uh you know it's pretty i mean it's its own popularity especially for memory safety and all those was it ever considered like sort of you know something around when julia was came into play like something like rust or equivalent or rust in those guys rest is a great language i like that though i must say that i i look at it as an outsider played with it but never gone deep into it it's not my cup of tea because i've been pretty much focused on ai the last few years, many years now. REST is a good systems language. A lot of people are totally in love with REST. The jury is out there. I think a lot of code is being written. New code has been written in REST and Go languages. A good thing. But in data science, their penetration is very low as of this moment. Data science AI is dominated by R, Python, and Julia, in that order. But Julia, what do you think is placed like basically one language across, cuts across the layer from high level to low level. That's sort of the advantage of Julia. Absolutely, that's what it does. Very interesting, yeah, I have to look at it. Yeah, because Rust and quite similar, that's why I. Yeah, because rust time is quite familiar. That's why I was wondering, is it like rust or something that cuts across layers is not an easy problem to solve. Yeah. And guys, I have given a few sessions in Julia. If any one of you are interested in learning Julia, by all means discuss it in Slack. If sufficiently many of you are interested, I'll be happy to give another free day of Julia session, a free session on Julia for half a day. It's a lovely language. So, but the ecosystem is very small at this moment. Now coming back to Python, what we are going to do therefore is we are going to learn. So knowing that the power of a language comes from the library, what do we need to learn? Why did I go into this digression? The reason I went into this digression is to say that you don't have to learn the whole Python language in all its details. There are many, many things there that make sense and this and that. In due course of time, you'll pick all of that up. But to be productive in data science, what you need to learn are data science libraries, AI libraries, in particular NumPy, PyTorch, that we are going to use, TensorFlow, Keras. So because time is limited, we will focus our learning to the libraries rather than the language. And we will pick up that much of the language that we just need to be fluent with the libraries. And that part of the language is just these three things plus functions. And a little bit plus classes. That is if you are reading my code, you may notice that they are in classes. But the way I write classes is so simple. In another session, I'll explain the functions. So this is our session two, function seven, this session number two in Python. So today we'll limit ourselves to statements, conditionals and iteration. This is it because if you can pick this up, you can in principle do anything you want with the language, solve any problem you want within that, with that language, with that syntax. Are we together guys? So that is a long preamble. Let's now go back to our Jupyter notebook and actually do things So I just to clarify on the classes so you sort of viewing it as like hey I need to have some class structure, but that's it not really the true object worry that you're not trying to get there We won't go there. We will use very light object oriented. The only thing we'll use is in this particular workshop series, almost all the way to the end, we will subclass the base neural network. And think of it, if you don't want to learn what classes and objects, just think of it as a ritual, a style of coding you have to follow. In another session, I will of course introduce what classes are, but we don't use that. See object oriented programming has an interesting history. It was much loved and much hated over the years. When it came about, people were absolutely in love with it. It started out as from C language, there was C, then there was C with classes, and then there was a beautiful language called Smalltalk, if I remember right. There are a lot of other things, but I'm giving you the big high points or the highlights. Smalltalk was a lovely language that popularized structured ways of writing object-oriented code. Java was deeply influenced by Smalltalk, and of course its roots are in C++. Object-oriented languages became very popular for a long time. Then came the barbarians who started abusing it, you know as semi-literate people adopted Java and they misused it for a whole lot of messy code that they were creating. misused it for a whole lot of messy code that they were creating it because it's not only object-oriented programming got a lot of bad rap so as always they say right don't don't blame something good by the practitioners of it by looking at the false so that was certainly true with object-oriented programming it was a lot of people overdid and abused it and wrote verbose code. So where do we stand today? There was a reaction against object oriented programming. Then came functional programming and functional programming syntax. So today the state of the art is use object oriented functional code, functional programming code. That is the state of the art. And Ramki, you were there in my big data class. You remember? We did almost everything using functional style within the object oriented framework that's correct yes and that is the state of the art so we'll get there gradually but as they say rome wasn't built in a day we'll gradually pick it up yeah today we'll just focus on Today we'll just focus on one thing. Let me know guys when you see my notebook. So Asif any good books on Python? Is it Many good books. See guys, Python is not a language that you need books to learn go to the online site and the best way to learn python is by doing python get started use books as references there's nothing in nothing very profound about this language the beauty of python is that it's so simple so easy to get started especially from a data science perspective because we don't use we use only a limited part of python and that part is easy to start in a few hours so why bother reading books you you know there are a lot of udemy courses on or a coursera courses on python one of the popular ones is called python for everyone or python for everybody is called Python for everyone or Python for everybody in Coursera. You can take that, you know, you'll spend a better part of four, five, six weeks just learning Python. And you have to ask yourself, really, does it take that long or it just takes a few hours to pick up? Because the goal is to do AI, not to become a guru of python okay thank you so that is that so let's repeat what we just did i will create a new cell here and say let's do that x is equal to what what did i say 17 y is equal to 34 by the way i'll upload all of these notebooks. What have we done here? Take 17 and put it in a box named X. Right. So assignment statement. So this is called assignment statement. This is the way to read. So guys, always read from right to left likewise can you interpret um the second sentence you can interpret now when you how do we interpret z is equal to x plus y oh sorry x plus y so how would we interpret that we would say take Sorry, x plus y. So how would we interpret that? We would say take the value of x, load x, take x and y and, sorry, first we read from left to right, take y and add it to x and, actually don't add it to x, take what take x and add the two then store the results in a box named z does this statement make sense guys this is how we should read it essentially if you are beginning out with programming this is how you would read it essentially if you are beginning out with programming this is how you would read it is this looking simple guys what we talked so far so good now what what else can we do suppose now let's go to a loop or conditional. Suppose I say conditional branching. We can say if x is greater than let's say 15, then do something so one of the common things you do is you print things to the to the output you say the print the value of x is greater than 15 so when we run this statement what do you expect to happen you know whatever you wrote here gets printed out. And we just got introduced to something new. It's called a function. At this moment, take it for granted what this function is. We'll do more of it. But think of functions as commands. Whenever you see them opening with this curvy bracket and ending with a curvy bracket you should know that it is a function and functions are commands you are asking the machine to do something are we together here it did something that is an example of conditional on the other hand is why if I had to say if x is greater than 20 greater than 20 so what do you think will happen when we run this sentence nothing 20. So what do you think will happen when we run this sentence? Nothing, because the value, it won't act. It says execute this command only if the value of x is greater than 20. Isn't it? It wouldn't do that. But suppose we change the sentence to this. We put an else part of it we say else else else what value of X is less than or equal so now what will happen? Let's run this. So far, does it make sense, guys? Any feedback? I want it from those of you who are just picking up Python. Does this look simple? Yes, Asif. are. When I used if, if you look at it, the X, Y, and Z are column aligned, right? They start at the beginning of the left margin. But do you notice, and this if also started like that, but do you notice that there's some blank space before this? So Python actually uses this indentation to understand that this sentence should be done only if this condition is true. So see what happens if this print statement is here and I'll put another print statement here. Hello world. Now let's see what happens when I run this. I ran this, what happened? This statement got printed. Why? Because if this condition is true, this part is dependent on this, this indented part is dependent on this. But the part that is not indented is an independent part. It's almost like it is one line apart. It's just think of it like this, right? But I can make it dependent. If I add indentation, right, then it will become dependent on this. Are we together? So let me just say, if X is greater than 15, now what will happen? The value value of so let me make it the other way around then it is much more illustrative if i run this do you notice that the world hello world is printed even though x is not less than 15. Why did it get printed? Because only this part is bound by this conditional. This is independent of it and it doesn't get bound. But if I add an indentation to it, do you notice I added a space to it? Then suddenly this part too depends on it. Nothing comes out. Why? Because everything that is indented is hostage to abound by this part here that is uninvented. The conditional. This conditional has to be true for these things to be done. Now this is a surprise. People coming from C, C++, Java, et cetera, indentation is never an important part of the syntax you use semicolon at the end of the sentence and indentation you do for cleanliness of the reading readability of the code not for any other reason but in python indentation is part of the structure in c in for example let me write the equivalent C C++ Java code. By the way, you notice that I'm starting things with hash marks. Anything with hash mark means the computer will ignore it. It's meant for human readability. It's a comment in other words right people say it is a comment comment means it's a commentary the the word comment comes from commentary it's a commentary on the code written for some other human being to read are we together there's no brackets to say that this is part of that if statement yes exactly so if it was cc plus plus java you would do this if it is then then and here whether you indented or did not indent would not matter it simply wouldn't matter even if you wrote it like this this would not look clean. Your code review may not look so good. But this is still valid C++ Java syntax, isn't it? In other words, indentation doesn't matter except for code hygiene. But if you compare this with this, you'll notice that there are some things. It's more cluttered with this. There's more syntactic clutter. And so in Python, the brevity is emphasized people believe you know every culture has certain beliefs whether those beliefs are true or not so the belief of the python culture the pythonic way they say is that this is bad the The way this is written is bad. The way they write it is good because there is no syntactic clutter. You, if the code is more readable, right? I'll leave it to you to decide whether that's true. By the way, nothing prevents you from doing it. By the way, if it isn't Python, Java, you would C++, you would also put semicolons here what happens here let us say so I'll just comment this out or just divide it into another cell split cells so look at this code what if I did this will it work let's find out this is more CC++ Java is Java. What happens if after that I also did this? Now this code I hope begins to look very much like a C C++ Java code, right? What if I did this and I put everything here? Also, you would realize that invalid syntax the value of X is greater than okay it doesn't this one doesn't seem to like it the only thing I said that I think the semi code there's a colon at the end of if i think maybe that's the problem yes so there's a colon at the end if i like in uh invalid it's not like liking the semicolon so we'll have to remove the semicolon here print this print that so what happens is that this is very interesting this is not going to let you do that you can see that some things begin to bail out of you so we'll remove this then you notice I'm trying to make it look as see like as possible let's try a luck with this it went through so a lot of people who transition from C C++ what they do is they write the code in C C++ Java and then they start erasing things so for example if I took this code so let's see let's do that I erase the semicolons went fine that is good yeah then i went up and i removed this curvy brackets that also looks fine and then i put this well that is good that will work and then i can remove this and it would work right and then i have to remember that well it won't work till i indent it so there is a process you can go through to convert your C++ Java code C C++ Java code to Python code and I've seen quite a few people do it actually I must remember that I myself did it many many years ago moving to Python from C C++ I would just write it in my code Java code and then go erase things from it and it would become Python code if that is any use do that you can do that and it will work so that is something for you to remember so So anyway, so I'll remove the syntactic clutter. I'll keep it. And should I keep this Java part? I'll remove it. You're able to try these? Oh, yeah. Likewise. Now, so this is for conditionals and branching. Actually I should split it here. So here and make it a heading. Let's talk about the last thing now for today, which would be branch, which would be iteration. How would we do that let us do a simple thing we want to iterate over something a printout print hello ten times let us say so what you would do is uh and then just for like you could you could say like this for i in so there are two ways of doing actually i can do the simplest statement you could say i is equal to one or zero then you could say while i is less than 10 whatever you want to do here i'll say hello by the way in python whether you use a single double code a single code or double code doesn't matter so you notice that i'm starting with single code i have to end with single code or i can use double quotes. Both of them are treated equivalently. You can also use triple quotes if you really want to, but be consistent. Whatever you start with, end with that. Are we together? Now, where, and I'll talk about the differences between triple quote versus double quote versus single quote in a moment. Double quote and single quote are perfectly okay, but this gives you some advantage. Hello, find a. Notice something interesting. This worked because I started with single quote. So till I hit the end quote, a double quote will not be treated as a special character. This is something important to remember. But on the other hand, I can do the way, this is continuing to run because I forgot to do I plus I is equal to, you have to increase the value of I by one. You must increase the value of I by something. So now if I run this, it will print it only 10 times. So what did I do? What does the statement do? You take one and add it to the current value of I and put it back in the I box. So what will happen if I was four, it will now become five. And so you keep on testing whether i is less than 10 eventually i will become bigger than 10 because at each cycle each loop it is increasing by one increasing by one and so eventually this loop will break that's the word people use now you notice that i could get away with it. I use double quotes and this happened. So talking about this quotes business or the strings business, let me mention something. Python has one very nice thing. Suppose you, and this will be good for you, some of you. Suppose I have a statement, a message. You can actually do three quotes. And when you do three quotes, you can actually do three look three quotes and when you do three quotes you can say and so forth. When I run this, when I try to print this, see what happens. Print. What do you notice here? It preserves your multi-line syntax, isn't it, guys? So if you were doing it in C C++ Java, what you would be doing is you would be putting a backslash n. Do you remember that? Those of you who are familiar with those languages, you would be putting special characters to break line. In Python, you don't have to do that. You just can print it. By the way, now in Java also, you don't have to do that you just can print that by the way now in in java also you don't have to do that java now fully supports this multi-line syntax almost identically so how did you achieve that lost you there asif just started with three quotes not two do you notice that there are three double quotes yes when you start with three double quotes whatever you put here can be multi multi line and it will preserve the line breaks okay perfect okay that is that so this is about so let me give it a topic heading um sorry it's just to just to revise the rules like single or double quote is still across a single lines doesn't matter single or double quote is still across a single line. It doesn't matter. Single or double quote. You can choose what you want. You have to give explicit line breaks. Okay. So does it support backticks, Asif? Does it? No. Backticks, I don't think it supports. Try it out. I've never used it. We use it a lot in JavaScript. Backticks. Yeah. I don't think I have in Python. I have seen that very commonly. So this was an aside. Now what is the magic you did to highlight it in Jupiter notebook? You just did something. What is the magic you did to highlight it in Jupiter notebook? You just did something. What is that? Yeah. Okay. So here is what I do. So suppose you want to create a text heading. Who has a subheading? So suppose I say, and finally, and we can't do it. We learned the following. Following start, assignment, statement, statement, statement. We learned whatever, iteration, conditionings. and whatever I try conditionals right so this is you want it to be understood as text. I wrote it in the markup language. What I do is escape M and then control enter. So I see. Yeah. So there are a lot of short, the keyword shortcuts gradually, you'll develop muscle memory. So you'll become very, very efficient with Jupyter notebooks. It has a lot of keyboard accelerators. You can go here. Do you see the keyboard shortcuts? Got it. You can use it and become familiar with it. See, you can't learn all of it in one day. Right. But what I would suggest is start with some common ones. Let's say that start with these, pick two, three, every month pick one or two and become familiar with it. Soon you'll develop muscle memory about all this because it's such a long list you can't just suddenly do everything in one go. So ask if there is any reason why you kind of split up into these boxes. Is it because you want to do it that way or? Yeah. So these boxes are called cells. Okay. This is a cell. So notebook, a Jupiter notebook is a collection of cells. The cells could be of one of two types either code or mark markdown forget about the raw nb and headings and all that either code code means it's a jupiter it's your python code like actually the word jupiter comes by putting three languages together can you guess what those three languages are three languages are julia python r yes exactly the word jupiter so let me just mention that jupiter the word jupiter comes from that is why it's misspelled like that like that you Peter sorry Julia I that's where it comes from you piter so so guys for iteration I would like to teach you more days for loop. So what have we missed and what we should have covered, but we'll do it in the next session today we have been going on for three and a half hours now. So again, this is This is for the next time what are we going to do we're going to do this we're going to understand uh for loops loops there's something beautiful that you don't see in other languages you don't see in c++, Python, these are called comprehension and generators. These are very elegant things. The for loop, of course, you'll become familiar with in no time. But because for loops and comprehensions and generators go together, I'll discuss it the next time as a separate topic. And list comprehensions and generators are absolutely marvelous as features of Python. I really like those. And we'll talk about it the next time. This was actually really good. And glad that you also like enforcing this typing rule, right? So basically type hint. That's really good. It makes it then like if you do that correctly, then it gets like to Java level or C++ level, you know, pretty much. If I haven't provided you to it. Absolutely. I talked about type hinting so if you were to go back and read my code let's say any one of them transfer learning do you notice that i give the return value everywhere create compose i say what each thing is classify result is okay a list do you notice that i say that create labels will return you a list of strings wherever needed like wherever there is a need to do that i do that uh if you go to the data set c4 you will see me use this quite a bit target you see this self target self is implicit oh yeah you see the type hinting and the return value here perfect no it's actually I think it's a very important coding practice like a secure coding right like secure coding with python that's what you're getting at yeah it is one of the best practices that very few people practice i know yeah yeah i never do this thing as it's always so much on python 2.7 i knew something but i never do this thing existed actually so yeah it's important when you start out to start out the right way correct so with that i'll end today's session it's almost four o'clock i will open it up to questions. I'll stop sharing and should I stop the recording guys before we have the questions?