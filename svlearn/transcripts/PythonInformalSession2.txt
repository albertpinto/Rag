 All right folks, this meeting is being recorded and we are here. So remember I said that Python and for example C or C++ and Java, Python differs from those languages in one important way. One fundamental way it is different. Could somebody remind me what that was? In case of Python, you can assign like, for example, five to this variable X and then in the next one, you can assign like a string to the same variable X and it would not mind. That is what and so the preferred thing that is emerging as a best practices. While that leads to easy code, quick code, later on if you want people to remember or understand what you said, you may want to do this. Let's say that suppose you're defining x. You can say x int is equal to five. So here what happens is that it doesn't actually guarantee that you can't assign potatoes to X for example you can still say X is equal to potatoes and it would still work if you did a print X what will come out potatoes will come out so in in Java or C, of course this wouldn't be. The moment you declared index is five, it will never let you assign potatoes to X. It's something you have to be aware of. But this is called type hinting. People have different opinions about type hinting. I know that some of my colleagues, some of the people who work in my team. So I have, for example, three data science teams under me. Two of them actually like type hinting. One team will absolutely refuse to ever use type hinting. They say, oh, it clutters up the code we like to keep the code simple and easier to read so it's a little bit about where you stand on with that and obviously I respect their vision so but my own preference is type inting is a good thing if possible do type inting and I'll let you guys decide whether it's a good syntax compared to this, if this is a good syntax or not. For example, let me put it here. Whether you believe the second line is more complicated than the first, especially when you declare functions and things like that, it's more important. Now, a list can be like this. Let us go through a few operations, by the way, conversions. I told you that if you want to convert a thing to another data type, like a number to a string or something like that, you give the string function. You want to convert a string to a number, you give it whatever it is like here. Do you see these things happening? So these are called type conversions. You have just converted things to whatever it is that you want to convert them to. Now what happens if you try to convert x, x, st, like x-accent suppose suppose I try to convert x which is accent excess potatoes I try to convert potatoes into an integer how many how many potatoes how many potatoes will I get let's see oh sorry Oh sorry, xxint and then I say print. Sorry not strint. How many potatoes do you think will come out of this? Anybody would like to guess remember X was 5 so X was potatoes now what do you think will happen when I run this line any idea Any idea? Number of unique letters in potatoes. Let's see what happens. What happened? Invalid literal for int. In other words, it does what happens in other languages in Java and C. What happens when you try to convert a string into a number, you get a number format exception of some form, isn't it? And that is what has happened. This is a value error, it has raised an exception and it is giving you the message invalid literal for int with base term. In other words, it has no way to convert potatoes into an integer. So it's something to remember right but conversions can fail especially when you're doing a conversion to numbers your conversions can fail converting anything to string most of the time works I can't think of reasons but it wouldn't but converting things from strings to integer or float you may have issues it may not work so for example one two three four now what would happen suppose I do this what do you think will happen if I do apples once again it will say it cannot convert one even though part of it is a floating point, is a number, there is no way it can convert because the word app is just present. Now today, remember the last time I introduced you to the F syntax, the new way for writing strings. So suppose you have a string, a text is equal to go ahead please no i've shared that uh last times notebook with you so if we can continue using that because yeah i'll review that thank you you sent it by email or you shared it on this session from last time we can open it okay continue writing on that so we have one okay let me go to you have shared it on github no on the collab itself shared on Asif, it's a port vector. I don't see. What's the way to see it here? Maybe you have to go to your email, Asif. I have to go to my email, isn't it? Okay, wow. Let me go there. No, it doesn't pop up that way. Okay. Yes. Oh, there we go. Oh, no, I requested access from the wrong email. Assign in as Okay. Connected apps. That'll be a little bit painful. I thought it's showing up on Google on its own. It's great for things that it works, but it has a rather minimal negative. Oh yes. This, this, thank you for how did I how did you get this because I shared it. Yeah, I shared it in Slacks I copy copy a state of So this is it anyway, so I'll go back and forth between the two for one reason so this is back and forth between the two for one reason so this is okay conditions so let's review this we did assignments X is equal to 5 remember what we said here the closest thing you can come to see style is this X colon int is equal to this and also remember the type hinting is just a suggestion. The compiler, the interpreter will not respect it. There's no compiler, the interpreter won't respect it. Conditionals, just to review last time, we learned to do conditionals, right? Suppose we say x's value is 20 and we have a condition that says if X is between 10 and 30 print something else print something else right here we have so if you think about it there one easy way that I suggest to people who come from backgrounds in C or C++ or Java or something like that if you do come from that background you should write it as though you're writing it in C or C++ and then slowly translate it so you notice that here if I did not have this semicolon this would be valid C C C++ Java statement almost okay except that it will be C out printf or something like that line number would you agree that this is practically CC plus plus Java right some variation of it and all you have to do is to make it Python in the beginning is just do this and it becomes valid Python code and of course if it is print F make it print and so forth minor cosmetic changes and from there you can start your journey to make it more Pythonic a very much suggest and those of you are lucky enough not to know C C++ Java right you can have of course start straight with the Pythonic format the younger people are like that they don't know C C++ Java quite often. They start straight with Python. And so Python looks natural to them. When they come to C, C++, Java, they actually find it hard. They pick up, but they find it harder. Now, but for a lot of people in our generation who, whose staple diet was Fortran, C, C++, Java, that's certainly my story. Started with Fortran, that C++ I remember doing writing my first line of C in 19 1987 that was 23 years ago in India so obviously Python came in 1990s so much later so well that's that so you can make it more Pythonic by removing the braces if you look at this and this the only difference you see is that the braces are missing unnecessary syntax letter has been removed and then you can get it even more Pythonic by writing it do you see the progression guys this this is beginning to look not that different from C It just looks neater than C or Java and then here Then yet a little bit more cleaner. Now you notice that the conditional looks more elegant This is the way mathematicians would talk about it, isn't it? 10 is less than X is less than 30 it isn't it 10 is less than X is less than 30 do those of you who are familiar with mathematics remember much of your algebra you remember the textbooks talk about things like that so it's beginning to look a little bit more like that it's not lot cleaner and then you can keep on going that you can say do this if this condition is true else do this so that makes it that makes it a syntax that is somewhat unique to Python maybe other languages have it but certainly you can't do it in C or Java C C plus and finally you could do something that is very unusual. It says that here is a condition. If this condition is false, pick the first one. If the condition is true, pick the second one. Actually, I like this sometimes because to me, this often looks like a one-liner that, especially if you read the code the way I often feel we should read the code from right to left rather than left to right it's very natural if this condition is true or false false this true this and then you can print it out you guys remember this so this is a review and so if you look at this syntax it is quite a journey we have come to starting from something like this. Then we have iterations, iterations you can do a looping, you can do with for loop and while loop, but there is something else that is pretty elegant in Python. So here we go. Suppose you have a list here. For values in this list, you can put the square of it. So A is here and B would be something like this. One, two, three, four, seven. And you're putting the square of it here. And then you print the value of B. You have done this. Could we have done this with a while loop? Would somebody like to suggest a while loop for doing this? Let's do it with a while loop. What would You would say index is equal to zero while index is less than length of the length of the list A. Do what? Square and you would say what you have to remember to do index is equal to index plus one. There is a shortcut you can do plus is plus is equal to to one right which but I won't do that because some of you are just getting started with Python or any programming as a first language so you would do like this and once you have done like this you can still say print had to run this so now what happened why did we get so many of these we need to break so while index is less than this uh index is equal to index plus one so let us say what happens when index becomes the length of it you increase it otherwise what happens i think uh interesting i might seem to be missing the fundamentals here of the while loop. I usually rarely ever use the while loop. I mostly use the for loop, but it's good. It'll be a review for me too. Let's figure out what went wrong here. Square length is B see one way you can do that is if index we could do this but this should not be necessary do while index less than or equal to length of it yeah oh yeah that would be the condition I think that I missed because it's the corner case when it is equal to that no it's getting oh you know what I know why no see I have to start this all over again so there was no problem I just have to remember we are carrying this list from the past so it is appending to the list it was just appending to the list that's all that was happening so now yeah it wasn't there oh B is this and index is zero why is index not getting reset to zero this is odd odd. Square is, oh, square is square value. So yeah, this is another silly thing here. I have to do index a. So let's look at this syntax. What we are saying is it start with zero first. So you look at a zero. Now this is a way. What is this way? What is, what is a zero? A is the first element. A1, 2, 3, 4. So there are five elements and the last element has an index less than the length of the list. That is why you say it like this. The star star 2 is actually a way of squaring a number. So here there are two ways I did it. Here I literally multiplied a number by itself. is one way to square it another way to square it is to do stuff and it is not just square so suppose I want to do the fourth power I can just do star star 4 and as you notice these are much bigger numbers, isn't it? So you can play with this right but then While these are ways and really it's been quite a while since I use the for loop I don't know why I see it in other people's code, but I tend not to my solution I mostly use the I mean sorry while you I mostly use the for loop But even that I tend to use sparingly my first option is can I get away with something called a list comprehension do you notice that this is I I achieve in one line what is achieved in one two three four five six lines isn't it and once you get used to this notation of list comprehension it just feels more I hope the fonts look bigger now it feels more elegant what it says is that for a value in a create value times this and by the way here also I could have said value star star t, it would produce the same thing. Or if I want the fourth power, I could have said fourth power. Okay. So it's just a, when there is a one-to-one mapping between an element of a previous list and an element of a new list, you can create the new list just like this. And this way is called list comprehension. So anybody wants me to explain it further or you pretty much got the idea. Yeah, I just have one question. Where is it getting this value for value like you have defined value previously no you're defining it literally here it is a dummy variable oh okay right but here you don't have to go ahead sorry just one just one last question. Here you don't have to use indexing though, right? So what happens is one of the things that has happened in programming is, oh guys, there's one more person who wanted to join in. Sorry to interrupt you. Can I give him a call? Yes, sure. Sure, sure. Okay. Sure, sure. All right, I couldn't reach him so we'll continue. So this is go ahead. I'll tell you question was, where is the index coming from? What has happened is over the years, people have moved away or tried to improve upon the C syntax. We are used to this. Are you familiar with the c language c c plus plus java uh not so much i'm familiar with fortran where we use the index so 14 is also similar you declare a variable isn't it in the index right now what people started doing is they started writing code like this so for example in a for this would be java code you would say int value in a so what you're basically saying is take every element of a call it value and do something with it right so a syntax like this when you say for value in A it means the following so suppose the values are in fact if I go back 1, 2, 3, 4, 7 these are the values so for each of these what it is saying is in the beginning value is equal to 1 then the value is equal to 2 then the value is equal to 3 let us say value is is equal one by one it will go through the entire sequence value is equal to five oh sorry seven and then what it will say is that go through this loop this is a standard fortran loop right and for each of them produce what value star star four all right let me just take two because i it's a little bit harder for me to compute the fourth power in my mind okay so this and that will be equal to one right then likewise this will produce what will this produce this will evaluate at this once again you do value star star two that will evaluate to four do you see right You keep on going with that value star star 2 again of 3 and you will do so basically let me, why say value? This evaluates to 3 and so this becomes 9. And this is how this list comprehension works. Star star 2 and this becomes, what is it, 16 and 7. 7 star star 2. It becomes 49. it's quite interesting you know when you teach you remember what things you don't use it's interesting I noticed that I haven't used violin okay so good do you see this and so you started with these here in one column to get these and that becomes the new list. That is the way to understand comprehension. Great. Thank you. And then the generator is the same thing. Just on that one, one on list comprehension. Yeah. If I use like a, I'm just trying to find the difference between that versus if I use a map function, which map every element to square it, right? Map function is a form of map. If you think map reduce, it is literally a map. And so Python has Lambda support. It's nice that you bring it up and why don't we cover that at some point? Okay How do you do functional programming in Python? We'll do that. Thanks. A generator is nothing but the same thing with lazy evaluation. So, in other words, it won't actually produce that list. But if you ask for values one by one, it will keep very, very lazily giving you values when you ask for it if you actually try to traverse the list B it will start producing the values as as you traverse it as you walk over B now why would you reuse generators sometimes what happens right in a lot of situations you need B as a concept, that it is a square of A. But when you actually work with it, you don't need more than two, three elements of B, maybe the first two, three. So then it was somewhat useless to produce a million values in B when you used only a few. So in situations like that, a list generator is very useful. You notice the type of the generator. If I do it as a generator and I try to produce it, it says it's a generator. Whereas when I try to produce this thing in a list comprehension, what does it do? it out. Anyway, this shortcut is there on your Jupyter. If you highlight a certain region and do control forward slash, it will put comments across all of them. So this is it. So one produces the actual values. The other only produces a generator object and not the values. So you have to print it. Then we talked about a dictionary. Dictionaries are key value pairs. Lots and lots of key values. A key value. So here the key is a string, value is a number. So for example, how many cabbages do I happen to have in my kitchen? Let's say two, onions 10, potatoes, lots of it, 12. And if I print it out, it's like that. How do I convert between data type? This is what you asked. Go ahead. Between the generator, the only, and the list comprehension, the only difference is the braces in the syntax? Exactly. That's all the difference. Instead of square, if you use curved braces, it becomes a generator. Yeah, that's... It's very neat actually. Python has, see every language, right, has some very neat features so that if you use a language, any language properly, you will soon fall in love with that language. And take any language it is. People who do C programming, they absolutely swear by C. They feel that every other effort to improve upon C was a wasted effort. Nothing is so nice as C. Whereas those people who do C++, they absolutely love the standard template library, STL, and all of that syntax. Then you talk to people in Java, they have their own bag of tricks and they absolutely love Java. Same true with Scala. I mean, these are the languages I'm heavily into and then likewise the same is true for R and Python. You do in R and you can't for the life of you understand why people want to do anything in Python because the same thing you do in almost a third of the code. So, and then you come to Python and then Python has its own bag of tricks. So each language is lovely in its own way. It's very powerful features. So that's that. So how do we convert from one to the other? We talked about it. Now guys, it do take that I use the F notation for strings. Did you see that? If I put F before a string, it becomes a formatted string, which means that I can actually put a variable value in this curly braces. So by now you must have noticed that in Python, all these braces, like in every programming language, they all have special meaning. A square bracket is a list, a curve bracket, if it has quantities in it, it's a tuple. And tuples don't change. We'll talk about that. But here are curly braces. Curly braces are value holders in this particular case of the value of variables so do we understand these two lines guys what am I doing here I'm taking 23 and printing the value of 23 I am multiplying X marks three times X we realize what would happen if i do if i multiply a string by three it just repeats three times over whereas if i really want three times 23 i need to first convert it into an integer right and once i can convert it into by the way this is one thing that's really nice jupiter doesn't have as good a support but do you notice that colab gives you the whole definition you just mouse over it and the whole definition of the function is there right it's very nice actually so you should use that print is it's a built-in function of Python so alright you can play with this so you can see that the x value is the value of x let's try it again 23 if you just multiply it by 3 as a string just 23 will repeat three times but if you want to treat it as a number you need to first convert it into a number int x then it becomes a number and if you print it it will become what you really expect which is 69 right 42 again you can convert an integer into a string right and you can take a integer value why it can multiply that by actually here you don't need to why into why was anyway integer so suppose I do this 42.56 now let's look at it you notice that Y is 42.56 so when I print it as a string it will print 42.56. But when I take it as an integer, what happened to the integer? Yeah, actually, let me do this. Forget this. What would be the integer value of y? Just 42. Why? Because it takes away the decimal parts i just converted it to this integer so it's it's basic type conversion if it is not your first language then type conversion will look very intuitive but if it is the first time you're programming then you need to spend some time making yourself familiar with type conversions making yourself familiar with type conversions. So that's that. Then, last time, make a user guess a number. You remember that? So this is a code. I won't repeat this code because we want to do new things today. But does this make sense, guys, to you? Were you guys all able to follow this code? Yes. Yeah, we don't need to review this. Okay, so I'll move forward then we'll talk. Let's go back and see in the other one if I have something else. So I want to show you the old format of strengths by the way. You notice that if I have a list of numbers here and I want to print the length of the list, I use the dot format, a string dot format and I give the value, ll being the list. What has happened is this used to be the way you'll see a lot of old Python code to be there. But with the F format coming in, you don't need to use this. You can directly use the F format. Now, given a list, you can do many operations on a list. One of the things is, suppose you wanted to reverse the list right in other words you want six to be first 17 to be next 11 after that and so forth so how would you do that this is the way you would reverse the list a little dot reverse let's see whether it actually works or not here we go the length of the lens list is this when you reverse the list. The length of the list is this. When you reverse the list, well, we should print the list out in the beginning. Let me print out the list. Now let's use the F syntax, the new syntax. So here we go. The list is 1, 2, 3, 11, 17, 6. Length of the list is 6. There are 6 elements here. And actually let me deliberately change it to something else. I don't want it to be 5. Length of the list is 6 makes sense Reversing the list you get this. How do we get reverse of the list? You say dot reverse Right if you want to sort it you do dot sort But if you want to when you sort it do you notice that length of the list that it will go that length of the list that it will go in increasing order by default it always sorts an increasing order but if you want the opposite sorting you want to do a descending order sort you can say sort reverse so sort in decreasing order. How do you append something to the list? We already did that in the example. You can just go on appending an element to the list. When you append an element to the list, so for example, 19. So you'll see 19 is appended to the list. And what can you do? You can append go to the original list and I can say extend. And when you extend, what you get, do you see that you get the combination of both of those lists. If you want to know what is the 11th element in the list, it's very easy. You can just index. You can do index, right? Index of the, oh, sorry. If you want to know the 11th element, you'll just do list 11 in square bracket, but you can ask this question, where is 11 in the list? Like for example, in this list, where is 11? So if you really think about it, 11 is here. Right? You can do that by asking this question in the list. Give me the index of 11. It will return that. And when you print it out, it will say 11 is at index 2. So look at these two lines, guys. Would you agree that it is so? Index is 1. Index 1 means what position is that in? Second. Second position. Very good. That index is one index one means what position is that it second second position very good that's where it is right so ask if when it like we combine the two list uh is there a way to remove the duplicates is there a way that's a very good question so it is like using set right like so when you use set uh it automatically does it like since we are doing it without set uh so if there is a way to remove that duplicate well yeah let's see that's a very good question let's explore that together uh python let's google it this extend without duplicates yeah there it. It seems that a lot of people have asked this question. Let us do a list of Python without duplicates. Let's see. So one obvious way is to do the set, et cetera, but how can we do it without set? I can use list or extend delete list one but you know that is an explicit del list one use if else thank you for answers you can extract individual lists from lists well I wouldn't be impressed with that I think how about do you about the Union Union will keep the one L common one right yes actually why don't we try that math function union right yes union is true for a data frames let us see if it is true here it's good point. Why don't we try that out? Let me insert above. Are we have unique and distinct, right? Yeah. Yeah. Here we have set, we can do the same thing here. Yeah. You could do, see here's the thing. You could do ll.unique, right? And it will give you a number, right? Suppose you did this unique. Yeah. Two liner. it will give you a number right suppose you did this unique yeah two two liner no it won't but those are also part of series it doesn't have that uh what i would do is unique let's see if that will no i think you have to go and use set at the end of it you'll have to do something very silly use set at the end of it you'll have to do something very silly and you can do weird thing which is as you can see you you do a union but you do a set but Let us do ll.extend . If we did that and we print ll, we should get literally 100% duplicates. We get a lot of duplicates. Suppose we did this. So this is worth checking out. And suppose we did this. Union. Is the union supported? I don't know. Maybe it's affecting. Yeah, I think it's, yeah, union is not there. So the only thing I can think of is to do it like this. So suppose you have L ll.extend. I'll just pretend, Anil, that it's some other list for the time being. Okay. Yeah. Which is not the best way. I'm sure there must be a more elegant way of doing it. Terrible way, but I think it will get the work done. And let's see. Oops, none type object is not iterable. Set extent. So let's go over it. Oh, list set. What is this? None type object. LL seems to have disappeared. Let's go and recreate it. LL is here, dot extend. And then once we have done that yeah then we'll have to do this LL is equal to so for the time being we seem to have reached this far let's try a look there we go there must be a more way. I just don't know off the top of my head, but we can try a little bit more. Let's see if there's somebody has done a better job. What's that? List and set in that statement. Like what is the function list is just a list of numbers it can have duplicates a set will remove duplicates set inherently does not have duplicates okay so maybe a list comprehension with the not with the with the what Maybe using list comprehension and then... Yeah, so one year list comprehension, very good point. We could do it using a list comprehension. Let us do it using that by... where am I? Is this the one that we were... Conversion between types, value... no, no, I was in the other notebook one second here right so well that's a very good point that you raise so other way that we could have done it is let's go create let me leave this alone this is one way of doing it we could also have done it using this let us say a is equal to 1 2 3 let's say B is equal to 55 65 75 right so suppose we had to do a list comprehension so what we could do is we could do this X is equal to a value or value in a dot extend B if a list if a dot contains I think does the word contains exist contains value and well you know B doesn't contain a contains value and B does not continue I think we can say unique there right if we could do with this comprehension if what should we do with if if there are a extend b value in if a dot extend b dot index. So if b element is not in a, right? That's right. Yeah, what we can do is, yeah, that is a better, right? That's right. Yeah. What we can do is, yeah, that is a better way actually. That's a very good way to do it. Value for value in B. Very good. Excellent idea. If B, if B, A. Let us say not in A is supported or not. We'll find out it is and let's print X value for value in B what we'll do is a dot and a. Sorry. a dot append. Append. There we go. So you guys taught me something today. Very good. With less comprehension we did it. So Anil, there you go. And it feels logical, isn't it? To a append a value from b only if it is not already there in A. Makes sense. Very good. Yeah, this is good. The only thing is like if the original list has added duplicate value, then it won't work, right? Then it won't work. Yes, true so we can remember add only in either case set seems the good way to actually remove the duplicates also that's right this is this is sort of the straightforward way of doing it but let's yes nice to try it out with less comprehension which don't isn't a possibility to add a function margin delete yes so so this is our loop number thing now the while sector etc so sometimes you know it is'll do an exercise which is worth doing. Before you go there, just one question. So in this list, why didn't you have to use the print statement? You don't need to use a print statement, right? This is very much of a Jupyter thing. Only in Jupyter this will be true. That if you give the variable name, it automatically wraps it up in a print. Okay, thank you. It has to be the last line there. On the last line, if you just find a value, it will print it. Now guys, I'll try to do something practical suppose we open a file in my directory I have a file called sonics let's see if it is there sonics now sonics is something I'm fond of long ago, though hard to believe, there was a time when I was young too. And I was like, I suppose all young people, I was in love with poetry. And I used to love the famous, the Barts poems, you know, Shakespeare's poems. In fact, at one time I tried to memorize all of them I used to be very fond of them I still am very fond of them they're wonderful poems so these are Shakespeare's poems I just Then this text, I will now read the text and do something practical. We'll open this file. How do you open a file? By the way, this is not the best syntax, but it's the simplest syntax are we together I open this file called sonnet and what do I do I count the number of lines of text so number of lines initially I set it to zero and then I say all right for kangaroo in text I could why did I choose kangaroo I do I could have take a chosen anything it doesn't matter for word in text would have been better but I think at some point I was explaining it to people and they said why did I use the word variable word I could have used any variable so I changed it to candle right for word in text you just increase the line count does this does this code look easy guys think over it for a moment I'll comment it also in the file we open that file, then what do we do? increment the counter isn't it? So those of you who are finding if you find the syntax hard do please tell me. Final number of lines. Why is it line count and not word count? Oh, at this particular, oh sorry, you're right. Actually it is for text in the beginning it is actually line count, you're right. It is not the word count it is line then in a line if you again try to go after the words then we can do a double for loop so it is actually line you're right so a text a paragraph or lots of paragraphs the first thing you can get is if you try to iterate over it you get lines and if you iterate over any one line you'll get the word are we are we together now and thanks for catching my mistake I would have blended on so far so good does this make sense guys so this sort of code is very very common in Python to write code like this but now the question that you guys are just literally the next question well how about if I want to count the number of words let's run this and you can be a bit smarter if you want to just see the progress of things being printed out you can say print dot so what will happen now let's see I teach every time you read a line you print a dot oh you see a lots and lots and lots of dots followed by the number which is a bit tedious so we go to the word so how would we do the words? Let's think about it. And let us say that we want to see those words also. Here again, just to illustrate, I just changed the word to kangaroo, but let's change it to what it should be, line. What do these two, this is for every line. What am I doing here? I'm saying that any text can be split into words by invoking the word split on it. Are we together? We're making a list of the words. Exactly. We are making a list of the words. And then, but these are the words only in the line. So what do I need to do? All these words I need to add to this list. So I am doing it for every word I'm appending it to that. Can you think of a better way of doing it can you do it a little bit better see instead of this I could what if I had done this let me see so first let's verify that this will take you there so you agree that if all these words in this new list I can go on appending to the master master list of words does this code make sense guys right so what I do is I break a line into words then for every line I break it up into words and all the words happen to this and then I count the number of words I get this there is actually a syntax perhaps a little bit same syntax let's do a slightly different way I have a question like here the words is a list right words the words is a list yes now you can we just append that list to this previous list? It will be problematic because what will happen is, you want to see what happens if you append the list? Okay, let me do this. What if we append it? Let's do that experiment. What if we append it? Let us do that. So instead of this, we say all words. Oh, now let's see what happens. Should I run this? You notice something strange. The number of words only three zero two nine isn't it which also happens to be the number of lines so if you just print out these words just this looks like a mystery isn't it okay yeah that was you right oh yeah so suppose you print out all of this words. Let's try to print it out and see what happens. What do you notice? You get the... Oh, it's a list of lists, okay. Right, you get the list of lists. Yeah, it doesn't merge it. It doesn't do that. So now let's try another way. That didn't quite help. All words. Let's do this. I'll insert insert let's try another attempt we'll go back to the same code this code here and suppose I do this for this one question worth asking is can I iterate over the words themselves so can I do this? Instead of this, can I do for word in line, append all words, append word. For line in text, for word in line, I do this. Will this work? But if you do extend it should work, right? Yes, yes. You have to indent it with the word in line. Allwords.append.word needs a... indent error I think, yeah. That is... No, that's right. That one. Got it. Yeah. And when you do this, oh, the number of words is now excessively high. Here was 20,000 and now we got well this was too little and I'll get rid of this one this is too much what do you think happened if you try to inspect what happened you'll see and we are gradually coming to that you know I'm showing you all the ways that you can do suppose you did all this what do you notice I create over a text any string you will get one character at a time we don't want that so I'll remove this what we want to do is we don't want to do this so this won't work so now let's go to the next way, which is this. Extend. Do you notice that we do the extend here? And what do you expect here? If you do the extend, if you want to find the length of the word, this looks correct, isn't it? You get the words. You can say length of all words is correct, right? 20,701. So, at the end of it, what we are saying is instead of doing it like this, you could have used the extents and extents syntax will give it to you. And you can even sort it if you want. How do you sort all the words? Now you sort it by this. And by the way, how do you get the first few words or first few elements of a list? You know, it's slightly different. That you do in data frames. Here what you do is all words. Now it is the range notation you say from where let us say from 0 to 5 right see what happens you get the first five words isn't it except that 0 is not necessary 0 is implicit if you are starting from the beginning of it, it is implicit. Yes. Right? What happens if I do something else? Suppose I do... What do you think will happen now from the end of list or in three two right it will give you the last five words we see how it works guys this gave you the last five words. Do you see how it works, guys? This gave you the last five words. Suppose I did... Next thing. Suppose I did this. This. Five minus one. That is start from wherever you need to start up to five steps but go in this notation what just happened it gave you everything except and this will keep on going out except that skip the last for the fifth top fifth one so you know this game you can play so i'll show you something else also suppose you go from 0 to 10 in jumps of 2. so first of all let's look at the first 10 elements these are the 10 elements here right 10 elements here. Then suppose I did that but I did jumps of 2. See what happens. How many elements did you get? Just 5 isn't it? Because it's picking up only the alternate elements. Suppose I want to pick up only third element, every third element. Now how many will I get? Zero, this, that. so suppose I do four and actually let me just for comparison leave this there so you guys can see what I'm talking about words zero ten in steps of four let's do you notice that the first one is this then where does the word project come from two zero one two three this this is your next one and then one two three four here fourth element so it keeps jumping basically huh it keeps jumping one so this is a way to jump across sorry uh what's that? So we have that. So you got the idea, guys. So in Python, one of the nice things is that, and also frustrating thing is that, sometimes the syntax can be very cryptic. So for example, this syntax, when we say, when you're new, it sounds frustrating. When you get used to it, of course you start loving it. You wouldn't normally have thought that this give you all the minus five sorry would give you the last few words isn't it like in Java or see you don't have this syntax I think they are trying to introduce it but certainly doesn't exist that you can read a list in reverse as part of it. So anyway, let's get back to it. Now that we have read all the words of the sonnets, what can we do? We can find the number of unique words and sort it all. How would you find unique? Once again, you read all the words. This part is easy, guys. We have done it so far now. And then to make unique words, we use the set operation, right? And to count how many unique words are there, we find the length of it. Does this look straightforward? Guys, are you able to see my screen? Yes. Okay. So tell me. Sorry, what does line dot lower function doing there? Oh, right. Very good. Very good. But that is to convert any text into lowercase. Okay. So you don't want the word cat spelled with a capital C to be any different from the word cat in all in small letters, isn't it? cat in all in small letters isn't it i say it's very common that when you're counting words the first thing you do is you either make all of them uppercase or all of them lowercase okay thank you for line in text what does line mean here like every line anyway is basically saying that if you if you iterate over text you'll get one line of text at a time if you I create over text you will get one line at a time I think comes in the counting every word in that line okay yes this is it so you could you. Now how many unique words are there? Do you notice this is the old syntax of a string. If I were to make it the modern syntax, I would say there are unique uw.com words found and I wouldn't do all this. I'll share this notebook also guys as list and you want to convert it back as list. You can do that and here also as list suppose you want to print the first hundred elements. You could do it right here. Using F syntax. So you don't need to use the dot format syntax, which you will see in the older Python code. So this is, this is one of the nice things that Python see, Python is evolving fast. The last time I remember giving this explanation, I think it's been a year or so at that time, the F syntax was still new and now F syntax is pretty much well established so you see this guy's now suppose I give you the stars find the frequency of the words and print the ten most frequent words now this is getting complex by the way this is a typical interview questions I ask people in India when I'm hiring talent and I'll ask them how much programming experience you have. They'll assure me they have six, seven years experience. And the same used to be true here also, though these days almost all programmers are hired in India. And here also, when I would interview people, I would ask these typical questions as a starter to weed out people. And they would have done years of enterprise software development and so forth. But you say, go find the number of unique words. And right away, they would have difficulty writing. Very, I mean, barely 20% of the candidates would survive. Less than that would survive. Even a basic test like this find the unique words in a sorted order so now if you were to find the frequency oh yeah you forgot the sort somewhere now we have okay words top ten most frequent words how would you do that Let's again go back to all words that sort is already. Okay so far this much is easy guys. What have we done so far? Asif, when you said sorted in text, how does it sort like numbers? I understand ascending, descending. Oh, alphabetical, by alphabetical order. Does it sort only the words in alphabetical order, the letters in words too? Letters in words too. So what happens is that it's called the lexicographic order so the word Apple right and and abacus so abacus will come before Apple because a B like first the a matches then P is before P so abacus will come before Apple. Okay. Thank you. In that way. So now if you want to find frequency, what do we do? We just need to maintain a dictionary. Isn't it? Remember guys, a dictionary. You take a word. If the word is there in the dictionary, you increase its count. Otherwise you said it's the first time you encountered the word and you set its frequency to one. Does this make sense guys? So let's take an example suppose was frequent does not word value. Would you agree? This is what we can do. And if the word is there, if the word say, well, these are Shakespeare's sonnets, so perhaps the word heart should appear many, many times again then what do you do isn't it then increment its value. Isn't it? You would increment its value. So that's what we are doing. If the word is already there, let's say the word heart is already there, found in your dictionary, because you have encountered it before, all you do is, you increase its count by one. Otherwise, you haven't encountered that word. Add it to the dictionary and set the count to one but do you think your frequency counter will do the job guys isn't it and then all you do is you can tell how many elements there are, counts is equal to frequencies.items. It will tell you a key values for every word. What are the frequencies you can sort it? And how do you sort, by the way, this is the use of Lambda. This is something, what if you were asking for MapReduce, right? So sort it. How do I sort it? I say that given a key value, sorted by key, not the value. Sorry, sorted by value, not the word. Right? KV1. No, sorted by word, not the battery no no no i think you're after remember kb the first element of kb is zero kb zero kb zero would be the word kv one would be the value so an example of kb would be yes yes yes word and then value example of kb would be abaca seven or something. Heart 9. That's right. Something like this. Isn't it? So heart, the word would be the 0th element and the value would be, because you want to sort by value and you want to sort it decreasing because you want the most frequent words so it's quite interesting actually how elegant you can do this by the way this is a pretty complex quote let me just tell you that barely 5% of the candidates even succeed in getting through this they can do all sorts of things they can do data science and time for pandas and whatnot all the boiler things. They can do data science and try more pandas and whatnot. All the boilerplate stuff. They can even write a neural network for you. But most often they fail this test. But it is quite simple. You build a frequency table, you sort it, and then you just print it. So it says that the word the is very often used. So you would imagine that these common words would be very often used. Suppose you want to find out how often the word heart was used. How would you do that? You would say, frequencies. That's it, right? Sorry, it's not defined, I haven't done this. There we go, frequencies. So it turns out that in the sonnet, the word heart is used only 31 times. Isn't that surprising that in a sonnet that contains close to 20,000 words, you find the word heart used only 31,000. So you say maybe heart is not that much used. What about the word love? And... Hello? Yes, are you guys able to hear me? Yes. Yes, no problem Oh thousand times only a hundred and nine times the word love is used right so it's approximately if you take hundred it is it is used less than one percent of the time half a person 0.5 percent of the time the word love is used now you wonder what's going on because Shakespeare's poetry is all about well if you have ever read Shakespeare's sonnets you would realize that it is about love and feelings and all of that i don't know so here's one thing you will notice that the great poets they don't write i don't know my interpretation by the way uh if you listen to some cheap pop music right when you look at popular songs pop songs or pop music or whatever the verbiage is used for that, they tend to be very in the face words. They seem to have the word love or heart or whatever littered in every sentence or something like that. But I think if you really read good deep literature, you find that people use words very carefully and quite often they can say a lot without actually using the word but anyway something to think about way tangential but i happen to notice that there is an alternate way actually so this looks complicated isn't it oh these many lines of code to find out the most frequent words. There is actually a simpler way to do that. You, instead of doing all the hard, see here you have done all the hard work yourself. You have done it using plain Python, but actually Python comes up with something called a counter. Do you see a counter? There is a library called collections, which has a lot of useful things because we want to find the top end quite often in fact the whole world of business intelligence seems to be top end so um or rather top end appears quite frequently there so this part is clear guys we are just reading the words yes there's nothing magical here, reading the words. And then what you do is you instantiate a counter and to the counter you give all the words and then you can ask very intuitive questions, like for example this, give me the 10 most common words and it'll print it out. So would you agree that these two these two look a lot easier than this part isn't it especially when you are new to Python this is actually not hard but certainly this is more elegant or simpler in just to be able to do the whole thing and so that brings in the value of all these libraries that every language has this is true here. The same is true in Python, in Java and so forth. All these libraries that you use, all these languages that you use often, they have libraries. And libraries are your savior. They make your life easy. In fact, all of these things like Pandas and NumPy and Skicket Learn, they're all libraries that you use so that you don't have to write a machine learning algorithm from scratch. To write it from scratch is to do numerical programming, literally go down to primitives to know what an optimizer is, to know how to write a loss function and so on and so forth to be able to do the calculus but what do we do if you remember in decision tree and all this code we just use a couple of lines of code you instantiate a decision tree and you just say fit it to the data and the data exists as panda so libraries make your life a lot easier and again another reason why i would stop the lot easier. And again, another reason why I would stop the learning or exercise about Python, more or less here, because beyond this, we may do a little bit more, but beyond this gets point of diminishing returns from a machine learning perspective. How do you visualize, by the way, this was something, a basic data visualization. So this code, I hope, is familiar to all of you, right? You read data into a Pandas data frame, guys? Yeah. After that, if you want to plot it, one of the nice things is you can use data frame itself to plot it. Either you can use this syntax or better still just say df.plot.scatterplot. Are we together? And there is one more thing happening today these days you can actually use a different back-end to your system so for example if I want to use a book okay or I want to use a plotly all I need to do this is a new thing actually let me try and make it happen I have that syntax. Welcome to Collaboratory. I was doing it for you guys the other day. So by default, Pandas uses matplotlib as a plotting library in the backend. If you don't prefer that, you prefer to use something else, you can actually go and change. So look at this graph guys. You look at this graph here Suppose you didn't want to do this or one of the things you could do is you could change the back end You could say suppose I Say Don't know whether I have set up properly broadly on this machine or not, but we'll find out. There it is. Well, Plotly graph looks rather beautiful. It has no data in it, so something is off here. We'll have to see what that is. I'll comment this out and bring it as my project let me try ponder okay so yeah you have to set up your environment a little bit to get this to work yeah do you notice that what has happened do you see this new visualization that has come up days yes and bouquet is an interactive web visualization so for example you can pan into any region let's say you can pick so you can move around you can make selections you could zoom into do you notice that I'm able to zoom into this image so in other words, these images are not static They are Dynamic Right I can reset it I can download this image I can save it to something see here it got downloaded right like this and Then you could hover on a point you can see any point and it valued you know so the the the whole thing became interactive without me doing anything but without with me just changing the where is that the back end where is the back end one here where is the back end here I just changed the back end pandas okay one second it just happened like that just change the back sorry go ahead with it no it just happened like that you change the back end of the abstraction layer came in that's right interactivity most people don't know that it exists tabloids in trouble now yeah the whole I see come on those people have a lot of lead time but eventually an open source will catch up right and I was trying to tell you that the gap between production and data science is decreasing and this is one of the examples of how it is decreasing and I'm pretty you can call D3 like here as well like something D3 or is it totally different yeah not blocky is based on D3 that's why I wanted to plot layer that is very powerful they going to do a web page and send it to client like this right exactly so and now I brought it back to matplotlib it's here so you have the matplotlib version you have the book a version do you see that the same data is represented slightly differently it's by changing the back end you can do that now if you notice this to do well okay this line also, by the way, is not necessary. So the only line that you guys, most people do, they do this and then they do this, the scatterplot. But if you notice, I tend to be a little bit more careful beyond the basic scatterplot, let me just comment all other things out before I do anything else. I wrote this like this. This is a basic scatterplot. And unless you set, suppose I do this, just to reset to defaults. Well, already a lot of formatting has taken place, it looks better. But generally, the vanilla Matplotlib is not very powerful. And so people often assume that Matplotlib itself is not powerful. Actually, Matplotlib is very powerful. Most of the libraries sit on top of it and they add the extra bits of code that you forgot to add but you can do it for example if i want to do this work i can enable latex true and we have talked about it it it significantly improves the quality of the code and And let's say that I have it here, X. Let's do it interactively. I did it. Do you notice that this title has shown up here and it has all your Greek symbols and so forth, right, mathematical symbols properly put in, your X axis, Y axis. Now you can do even better. You can say $ X right that would happen okay long right and I must do sorry no it was right long arrow right long arrow what is going on oh not F R we are still getting an error because X dollar log right arrow is a double quarter no no no this is fine it's something actually is it I always keep getting this mixed up with its long right arrow along long right keyword this is double slash no we shouldn't need double slash something I'm doing wrong that I'll remember what it is it's something basically like it's not all right i'll remove it for the time uh x here let me just say x here actually we just did it in our other notebook let's see what am i doing silly here so do you have a syntax in your river careful notebook or right certainly i have done it carefully there where is that you were careful you were careful so if you look at this yes here we go oh I need to do a long right arrow yeah this is correct so all right I'll just copy this and see what happens into our primer. Where is it? Where is the text we were dealing with? Here we go. Oh, you know, okay, I got that. See, this is one of the limitations. No, no, no. The reason it isn't working is because here I'm doing data frame you know pandas data frame dot plot dot scatter and while I can do it on matplotlib plot pandas data frame does not yet support latex syntax and it begins to do you notice that i'm putting latex here in this right on the matplotlib itself but we put on the data frames plot df dot plot dot scatter x is equal to oh my goodness i i take it back this is being silly this is being terribly silly here i'm declaring the variables. I shouldn't be putting latex here. Sorry. Really silly. Okay. That explains. My apologies. See guys here, right? I'm specifying the X Y axis. I'm not giving the X label. I should have noticed that so now X do you see that X with long arrow is here and you can do plot Y I was trying to put it here without realizing that here it is a scatter method where I'm just specifying the data itself I was trying to put it here without realizing that here it is a scatter method where I'm just specifying the data itself. I was just being silly. All right, so now we get this, right? Now this style, this thing, we can add more style to it. So what you can do is the same plot I can do, I can set its size. I can, you notice that what am I doing now? I'm giving it a color now I'm giving it a color I'm giving it markers I'm increasing the transparency I'm doing line width right so you can go and then I'll give you an example of what happens do you notice that these dots now look a little bit better at least to me compared to just the raw dots here this blue dots you have this nice salmon colored dots which have transparency so it gets at least in my mind it gets a little bit prettier I don't know if you like me and then you add some good labels this is the part that I was talking about XY feature response you can say that X feature and Y is the response again and then you can add annotations say suppose you want to bring home a point this you want to show something this is the way to annotate a figure you see that I say where the XY coordinates what is the text to put and so on and so forth. Right. And you can put the text here, X is this. You can put another annotation. See, I put another annotation here. You can give it a nice title. This seems to be a sine wave. So, so in other words, once you have a good plot, you can spend quite some time making it professional or publication ready by playing with it. So, guys, I'll stop here for a reason. Today happens to be my wife's birthday and children and she are waiting downstairs with a cake. That's important. So let's take it up next week, guys. Where will you be putting the notebook, please? oh that's important so uh let's take it up next week guys where will you be putting the um notebook please on you oh you mean the notebook let me put post it to slack itself okay nice thank you okay thank you all right was it useful by the way very useful very useful i mean this is very useful very useful okay Okay, good. Thank you. So, yeah, wish your wife a happy birthday. Sure. Happy birthday, Sumita. Oh, she's there. She's downstairs. So let me stop the recording. Where's the stop?