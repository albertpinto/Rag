 All right guys, we'll get started now. So, let us review what we did the last time. Python intro. We have intro to Python. So we talked about the fact that storage units are called variables in Python. Python is a dynamically typed language. It means that you can put different things into the same box. A variable could be one moment containing an integer, another moment containing a string and so on and so forth. It is something to watch out for. And that brings us to the notion of type hinting that I'll introduce today. And you may have seen it in my code. Then we talked about the fact that you doing conditional sin in Python typically is if something is true you do this and when you look at this you see that in Python indentation matters. You don't have curly braces and things that you find in C, C++, Java. You don't see the statements end with semicolon. So there are no syntactic hints the Sanyam Bhutani.jnr- The indentation is the syntax part of the syntax. So what it means is that if you just, and this is a danger. Sanyam Bhutani.jnr- And people find quite annoying when they come from other languages to Python. If they just so much as reformat their file the code becomes completely different and it will behave differently. You need to get used to it. Once you get used to it, you may hate it, you may like it. Some people like it. They say the code is much neater, less verbose, less clutter. Some people hate it. They say that it shouldn't be so brittle that if you reformat the file, the code should just behave differently. But for better or for worse, it's a fact in the Python world. How does iteration look like loops? I said that we are going to do more powerful loops, but we did the while loop. While is you start out with some condition. While that condition is still true, you can keep doing things. And the hope is that you will gradually make that condition false. you can keep doing things. And the hope is that you will gradually make that condition false, otherwise in forever, you'll be in an infinite loop. The other feature of Python is that you can do multi-line strings as you can, right? So these were the things we did the last time. What we are going to do now is we are going to add a more to this. So let me create a section here and call it session two. September 19th. September 19th, 2020. So today what we learn is more ways of doing hydration looping so in how many ways can we do looping it does that quite a few ways and we learn quite a few of those ways we learn about the for loop which is something you may be familiar from many languages so just to give you an idea suppose you want to print something 20 times or 10 times you would write in a typical language like C, C++, Java, if you're familiar with, you would say int i is equal to 0, i less than 10, i plus plus. Does this make sense guys? Does this look a loop look familiar to you? I'm sorry. Right, so you do you have to see it. Do something. This is your typical this is let me just call it the classic for loop, the classic for loop in C++ Java. Now, how does it, and I'll just comment it out just to, because this in Python would not be a valid syntax. But before I do that, observe that you start with zero and the endpoint is not inclusive. In most computer science programming language, the rule is the left inclusive, right exclusive. You include the zero, but you exclude the 10. It's a right inclusive, left exclusive, sorryexclusive, sorry, left-inclusive, right-exclusive rule. Let me just call it a basic mnemonic. Left-inclusive, right-exclusive. So in other words, mathematicians also write it as, those of you who are familiar with mathematical notation, they would say a comma b means means start at a but end just before b do not include b are Are we together? This is the meaning of that. Actually, let me do one thing. Let me mark all of this as not the classic loop for German. Not the classic loop for Java. And we'll do something better. We'll indent it. Oh, sorry. And when we do that, hopefully it will. Yeah. So this is a classic loop. So how do we do it in python it's a good question to ask in python we do it slightly differently we would say for i in range right and you don't have to tell zero you could say zero but if you don't have to tell zero, you could say zero, but if you don't give zero, zero is implied. So when you say zero to 10, it means start from zero, but do not include 10. So it'll go from 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, but not 10. And usually this is the same as, means the same as this for, which is much more common in range, then do something. Now we will see, do something, let's say echo, I mean, print, print i. Are we together guys? This would be the equivalent of it now notice the missing curly brace and the importance of the colon the colon is the demarcator between the conditional and the thing to do and the presence of indentation so if I run this there go. I get all of these numbers. So this should look pretty easy to you. Isn't that easy? Does that make sense? So with that there, let us do something more sort of sophisticated. Suppose I do this. I already have a bunch of numbers. So now we'll introduce arrays or lists which are synonymous in Python. So let me just say that some counts, I'll just take counts. And then whenever you create a list or an array, which are synonymous, you start with square bracket. You see this counts? It's a square bracket. I can say 1, 2, 3, I don't know, 7, 11, 4, 9, some random number. Maybe I'll make it 12 just to show that this is not ordered. So this is it. these are some numbers, or maybe just call it numbers. Numbers, numbers, some numbers. Suppose I want to do a thing. I want the square of all of these numbers. How would I compute the square of a number? Let us just say I can do squares. Let us say compute compute squares of a list of numbers list an array as I said are synonymous in Python so I could do this I could start with an empty array empty list and I could do for let's use our previous syntax for item in a number for nn nums in other words in this list do that and you can say squares dot append n star n or n star star 2 right square so this is the notation for squaring it right or you could say n star n which is the same as n square right and so after you do this and you try to print the list let's see what happens print squares let's see what happens print squares let's see what happens and go down and see do you see that the squares have come about guys from here to here you got the squares so likewise suppose I want to keep track of I don't want just the squares, I want a map. It should say that this is the square of that. So what can I do now? I could say instead, I could start with a map. One question as a syntactical, why are we calling it append? It's like append means somehow it's like up and mean somehow it's like appending to existing data right yes so appending it to this list squares which you start out with an empty list and you're pending to okay okay oh it's an empty list okay no I know I somehow confused my the world numbs your numbs was different correct yeah it's a new it's a new list yeah so suppose you want a tape sorry like a number so in other words you don't know 144 is the square of what? N square. So suppose you want it like this, a key value set, right? Just say value set. So then how that what you do is that the data column map or a dictionary let me just call it squares dictionary people uh what in cc plus java people call maps hash map or hash in python will they use the word dictionary so whenever this is So when somebody is typing furiously, could you please mute yourself? So for number in nums, now what I would do is I would say squares and then key. What would be the key? The key is given by this, you would say, and and you would say is equal to and star, star, two. Right. And now let's try to print the Squares and see what happens. Oh, something. List assignment index out of range for any nouns something I did wrong square data I think the nn nums is actually the value of nums, right? So that's why it's going out of bounds. I guess the squares is like, so basically you have to do for some, the index of the list, right? So basically. Yes, my fault guys. the index of the list, right? So basically, I think I'm doing the... Oh, yes. My fault, guys. See, what I did is I started to do maps. I should not have added to this. Yes, it's a typo. I'm trying to add to the dictionary, isn't it? This is the key and this is the value. And when you do that, then, and I should not prevent print the list, but I should prevent the date. Yeah, exactly. Yeah. But now we can see it as a table guys and you see one square is 112 square is 144 three square is 97 square is 4911 is 121 and so forth. Does that make sense? So you got into to data structures and most of the time when you come to data science, these are the only, predominantly the data structures you'll need most of the time. You won't see any other data structures. It is as simple as that. If you got these two, you're done right now contrast that with things like cc plus plus java where there's a very rich set of color data structures it turns out python also has a collections module of a package which has a lot of very good data structures but most of the people they can i mean they for simple uses they don't that. Data science people in particular don't use very often those structures. The reason being, Python is a very slow language. You don't want to iterate over or run through a long list or a dictionary. So I'll give you an example. Suppose you create a list of a million numbers, and you want to iterate over it and find the squares of them. If you do it in Python, you'll literally be a hundred or a thousand times slower than doing it in C. So what people have done is that because machine learning or artificial intelligence, the foundation is numerical computing and those numerical computing libraries have long ago been perfected by people the older generation of people like people like me even before me actually so when I was in grad school a lot of these libraries were already perfect they were written in Fortran so those libraries lived the blast basically in your algebra system, et cetera, et cetera. Linpack, Lapack, Atlas, C, those are all Fortran and C libraries. So what people have done is they have created Python bindings for it. And when you use that, then your operations are extremely fast, like lightning fast. Are we together? So maybe I could sort of illustrate that. I don't know if this illustration will work. I'm just doing it off the top. But first let me introduce how you can do that. So when you create an array so suppose you create a array in a nums right one way to create some numbers let me just use uh l uh simple list simple list is simple array is equal to we can say range is equal to, we can say range zero, let's say zero, or you can say one to one million, one, zero, zero, zero, zero, zero, zero. So it's a one to one million, isn't it? Let's see if this runs through, by the way. Yes. And so what is the length of this? The way you find the length of an array is you can say simple, apply the length command. Length command can be applied to all sorts of things in Python. And when you do it, it will say there are million items. See, if I didn't understand the use of the constant there. Inside range, you said one comma, then you had a one underscore something. So the underscore is just for readability. Otherwise you're busy counting zeros. So you just for readability, you put underscore and you put it in groups of three. That is how we in the US, we always go in terms of 1000 million billion Equivalent of a comma in normal notation, but since comma has a special purpose. Okay. You got it. You use underscore here. And so suppose I do something and I hope this experiment works suppose i want to find the squares square of array so how would you find the square of array right let us say that this is we use our typical list what we just learned so how would we do it by now for n in simple array Or n in simple array, right? For n in simple array, square of array is equal to, you would say, sorry, n star n, isn't it? Or n star star 2, let us say. Let us run this and let's see how long it takes to compute it. So I'll hit enter. It took 179 milliseconds. Unfortunately, my machine is straight away on a slow hardware. Now, what happens in Python for data science, especially in our field, we don't use arrays like this. We just try to avoid it because it's too slow computationally. So now what we do is, suppose I do this, np array, there's something called numpy, and I will import that library, import NumPy as np. So what NumPy is, it is basically the arrays, multi-dimensional arrays that are actually implemented in Fortran underneath it. And nothing on earth ever beats Fortran, unless you write hand assembly code and then also it's doubtful it will beat Fortran but Fortran is just absolutely what you use for scientific computing so somebody once asked is there anybody still writing or you'll be surprised to know that most scientific computing especially weather simulation and complex fluid dynamics and ocean ocean dynamics everything and large particle accelerator simulations they are still all done in Fortran so NP yeah let me finish this then I'll take go ahead square of arrays dot append. That's correct. Yeah. Oh, this didn't work. I apologize. Square of arrays dot append. It should be, I take this back. That's why I was wondering. This is the right way. This is probably what you were asking. Yes, that's right. Thanks for catching that. This is the right way. This is probably what you were asking. Yes, that's right. That is right. Thanks for catching that. So here we go. We created a nullpy array. And now what I'm going to do is, suppose I want to find the square of it. And now, do you see the runtime of this? 14 milliseconds versus 216 milliseconds. Do you see the difference guys? Yes. It's significantly faster. And I could do more experiments. Like you could take, let's say that you have to multiply an array by each element by some random number or something like that. Suppose you do that. So I'll show you this experiment again. It's worth doing to bring out the data science perspective of it. So suppose I take another array. Another array is equal to, like at this moment, I would say random dot. So I'll have to import random, import random, import, sorry. I can't see my keyboard and import random. And I believe I should remember that random dot normal zero. Just one thought as of perhaps in this case, like the, since the data set is trivial, all zeros in a simple array, maybe the Python interpreted did some optimization. It could be in reality even worse, probably. The Python, the array is not zero. The array is not zero. So let me see that. I created an array. So yeah, yeah. You have an array from one to this. This is not zero. Let me print the first few elements. And so that brings up the question. Simple array is zero, right? I said that I was talking about the previous one sorry I didn't like bring context a simple array is all zeros right I thought oh no simple array no let's look at that so suppose I do the simple array right let's print out the first few elements I would do let's say up to ten elements see what happens I'm sorry range this is it gives you a range of numbers from zero to 10. Do you see that? Oh, yeah, yeah. That is basically when you say simple array, it will actually initialize to 01 like that each element that's what it does. That's right in fact oh it's not all zeros okay it's not all zeros so that's that so now something uh interesting has no normal so now the thing is uh this is where because i don't use the normal python all that much i myself tend to forget the syntax so let, let us go and find a normal Python, normal, normal distribution, random NumPy. No, no, that is normal. How do you do it in plain Python? No, this is NumPy random, random.normal. No. Okay. Python, Python itself. All right, let me just say Python random number. Let us just use that. Thing is numbers in Python. So basic thing, numbers in Python. So this is it. You get so used to generating, working with scientific libraries gradually you begin to, as I said, you don't remember, oh, I apologize, this is late. Where am I? So let me just say random.random. So you generate a thousand random numbers. Let's see a million random numbers. Will this succeed? Takes no argument. One thousand. Yeah. So one one times this. So here we go. We have created about a thousand random numbers, another array. And now I'm going to add, multiply the two elements of that. So imagine that you do dot product means you do a pairwise multiplication, i.e., a pairwise elementwise multiplication. So how would you do that? You would say that for, let's say, number in the one array, x, y. But now you need to travel through both of the arrays at the same time. If you're going to multiply a number from here with a number from here, do you realize that we have to index it in such a way that we go together? Right, guys? index it in such a way that we go together right guys so we can do it like this for uh i a traditional way would be i in range one zero zero or you can just do length of it length of uh up to the length of simple array square of square off array okay of square, square of array, okay, of, square, no, array, simple array, simple array, for up to this length, what will you do? You will say, you will create another thing, let's say that a result, a last array, which will be the pairwise dot product of these two so you would say a result append what would you do you would say simple array I star the other one another array and I does this make sense things and this yes yeah this will produce your array uh yes let's see how far how fast this can run and we'll see oh what did i oh sorry equal to sign i missed here and what did i miss once again simple array is for I in land int object is not a table Oh in Rick actually let me just say in not land sorry it should be range length etc etc let's just say for I in range okay we already know what the range is I'll just put the range explicitly here that was my mistake it is indeed true but the value is not incredible okay so let's do that and now where why are we unhappy float object in range append result.append simple i okay is not float object is not acceptable so here there is a subtlety that came in the simple array is actually an something called and i should introduce that it is something called generator so you can't actually do this with a generator so the simple array i'll just write one more thing here and you'll see why I do this simple array is equal to i for i in a range this is a very cryptic syntax just take it as a fact for the time being. And result is simple array i times another array i. A float object is not scriptable. Why did for I in any range okay this is a very something and now result I okay guys help me identify let's take this as exercise what could I have been doing wrong here? This illustrates that if you don't do something for a while, then it begins to break off. You do a lot of data science and you begin to forget the basic simple thing. Let me print this array. A few elements of the array, zero to 10. a few elements of the array, 0 to 10. Yeah, so this came through properly. So for i in, now, so now I don't need to do this. I can do this in range, i, okay. So yes, I don't need to do this. Simple array. simple array and result is equal to result dot append simple array another array so the problem is in the another array because it is an another array i The reason is that this happens to be, yeah, this was the problem here. See, you can't iterate over it because it's just a random number. It is one number. So I have to do for I in R. And I'll explain what this syntax is. I random. This is a funny syntax I wanted to explain, but let me use it before I explain it. Yes, now it will go through. Everything will go through. So that was it. The rest of the code was fine. So at this moment, let me make the point I'm making. But assume that this produces an array of random numbers. Do you see an array of random numbers, a million random numbers? I printed out the first 10. Let me comment this. Produce an array. So this was it. Actually, I really think I'm using the Python's native random after a very, very long time, almost years. Generate a lot of random a lot of random numbers in Python, in Python, not use one of the libraries. So this is what this does. And simple array is just a bunch of numbers here. Actually, I didn't need to do any of this. I in range would have been just fine. But here we go. We are multiplying these two. And it took 129 milliseconds to do. Now see what happens if I do a similar bit of code using numpy. So suppose you have a numpy array. So let me just take the array to be x, right? x is equal to np.ar range, pretty much the same thing I'll do, A range 0 to 1, 1, 0, 0, 0, 0, 0, 1. You have an array of this. I will also generate a Y. Right. You have an array of this. I will also generate a y. Now this time I'll use numpy.random. Import np numpy.random. Right. That's random. And now if you do is equal to random. And now if you do is equal to random dot normal. I'll just take a, I could have done random or one, and I'll take a number one underscore zero, zero, zero, zero. So many values. You now, and now see how fast it goes. And this is the point. Suppose I want to do a dot product. First of all, look at the simplicity of the syntax, X star Y. I'm sorry. Oh, one has a shape greater ring shape zero zero zero then we have you notice so guys notice the difference here you see this syntax. We are multiplying these two arrays. It takes 129 milliseconds and this takes 11 milliseconds. And it gets much worse if I add a few, let's make it a billion. Oh, give me a moment. Zero. And suppose I do it for a billion lines. And obviously, I need to make sure that this another array also is a billion. Billion. I need to run that also. Right. And first of all, notice how long it takes for it to generate a billion items, execution queued. And even here, it is taking a very long time to just produce so many numbers. Do we see that guys? In fact, I don't think simple Python will survive this. It might not. Restart the kernel. Oh, it may just crash. Hi, it may just crash. This is it. The Python, remember, is a scripting language. It's not really meant for heavy duty stuff, the plain Python. So when you, in machine learning, when you think you're writing code in Python you're not really writing code in Python you're writing code actually in Fortran and C but it looks as though you're writing code in Python so let me run this now oh goodness I don't think this will even finish. So let's not try to even make it finish, but it sort of illustrates the point. But now I've used some peculiar syntax. Restart. I've used some peculiar syntax and I'll explain it. First thing you notice guys, that before I go into it, assume that these two arrays exist, a simple array and another array exist. Would you agree that this is much more harder to understand than this, just X star Y? Yes. Yep. Isn't it? And this is the point that in data science, we use the NumPy library, which is basically Fortran library under the covers. And this supports, Fortran has one beautiful thing. It is, it stands for formula translation. And quite literally the way you write it in mathematics on a piece of paper, your code will look very close to this. Right? And that is a huge positive. Besides the fact that it runs much, much faster in NumPy than it runs in Python. Normal Python pretty much bails out on you after a little while. So in fact, it's a long time that I ever did these things in normal Python, which is why you see me trying to recollect things, fumble around. But go ahead. Sajeevan G. Do you have destructuring concepts in Python? Like say if you have a long array and you want to automatically assign certain values to variables like in JavaScript, there's a concept called destructuring. Is that there in Python? I'm just curious. Give an example. So suppose you want to create an array and you want to fill all of it with two. Okay. So let's take an example. Say an array has three elements, say one, three and then i say a comma b is equal to that error correct automatically in javascript a is equal to one and b is equal to two the first two elements get assigned so i don't have to define those values they automatically in any other language i have to say int a and then assign them we have it yes python has that same convenience a slightly different syntax and you'll come to it it is very elegant actually that the return values of this thing so what you're talking about it's a little bit of a digression but i'll say that so suppose uh sorry um suppose you want to do uh like this a b c equal to two three right this will work just fine right and these things work uh they take the right place for this, but there's more to it. I know what you're coming to. We'll come to it gradually, but at this moment, let's pay attention to it. So the first thing we realize is NumPy is far more simple syntax than the normal Python, which is why I said the only Python we need is a basic amount of Python because we'll be using data science. AI is all about NumPy and PyTorch and TensorFlow and scikit-learn. It's not so much about the vanilla data structures in Python. You know your for loops, your viles, et cetera, et cetera, and basic functions and bit of classes and you're done. So now I'm going to teach you something about what is called So now I'm going to teach you something about what is called list comprehension. Sorry. List comprehension. I have used it above. You didn't realize it. But I will now do it in a more structured way. So suppose you have a list. So let's take a list X is equal to once again I will take one two three four five six seven eight nine ten suppose I have a list like that and suppose you want to take a condition. You want to create another list, y, which is made up of, suppose the problem is create a list, y, which is made of the square roots of x. So how would you do that a traditional way you could say is that y is equal to this right and then you would say right? So, uh, if you're doing num PI, it would be, so let's import num PI here somewhere, which is bad practice. You should put the inputs at the top, but we'll do it here. And you go here and again, let me center it. And pi dot sqrt x, right? And you can say y dot append. Now root, there it goes through. So there you are. What have you done? You have created, and let's print out a few elements. Why not print y out? It should be easy. So you can see that y is made up of the square roots of these numbers, isn't it? y dot append and so forth. Now this is, oh sorry, what I did was silly. Num root for num, not that. I apologize. So now you have 10 square root. I was wondering how did I get that so many. So far so good, guys. We agree that the square root of 2 is 1.4, 3 is 1.7, 4 is 2, and so forth. So we do it like this. Now still within normal Python, there is one more syntax which is more elegant than this it is called list comprehension list country and this is something i find very elegant uh in python i like from in java i really miss that they don't have it in c plus c C Java. They're trying to have it. But so far, I think they don't have it. What I can do is I can say None stressed sql NP sql t num For in x see what am i doing i'm going to iterate over every element of x anyway you see this for num in x but i can write it right here and i can say for every number return me this is the return value return me the square of square root of num and now what happens is you will notice that this produces for you the same result. Do you see this guys? Now you would agree that this is, once you get used to it, this is a bit more elegant than this. Would you say that? Yes, definitely. Super elegant actually. Yeah. Yes, definitely. Definitely super elegant actually. Yeah. So Asif, you're running for that list. It's basically returning a method, correct? So you're calling a method for the right hand side. Yeah, no, what it is saying is that for every number in X, take the square and that's the return value. So you collect that into a new list so it's a mapping from a list to a list if you think functional programming right list comprehension is pretty much a mapping from one list to another you just tell which function you're applying to that each element of the list okay so numpy square root is the function you're applying to that it will uh work as long as there is a one-to-one mapping against it so it's a one-to-one if there is a one-to-one that's the only case it will work so that is another beautiful thing it doesn't have to be so let me show you what what if i i want to take it only for even numbers so suppose i say z is equal to list comprehension np dot sqrt num right for num in x if num um so basically it's uh at the back it's creating a dynamic, it's actually a dynamic array like Java, like probably like a correctness that dynamic, it's a list of dynamic, dynamic data structure. Right. So now you're Yeah, you're now what's it doing? It is computing the square root only if it is an even number. Interesting. Yeah. So you can do pretty amazing things in Python just by using list comprehension. So Asif, there you're using dot square root of num. Say, suppose I have an independent method. I can call that method and provide num to it. And that would return that particular result. Let's do that. I didn't teach you functions, but let us jump ahead and define a function. Function, I will do, let's just say, translate. Translate. I'll just put a creative function for that. Let us say that you give it a variable n and it returns yes for the fun of it n plus before we go into the function just on the list comprehension statement yeah like if num modulo 2 equal to 0 right. That has to be a single statement, right? That can't be, if you want to have one more condition, that can't happen. No, you can. If num is equal to 2 and num is not equal to, and num not equal to, not equal to 4, let us say, right? So now let's do that. You notice that now you get only 4 numbers because 4 has been avoided. So you have a complex Boolean condition there. Yes, you can be pretty sophisticated there. It's very nice actually. This is one of the things that makes you like the effectiveness of this. Now, suppose you define a function. By the way, I've explained function. I hope it's simple enough to understand what it is doing. Given a number, it will return the number plus 3. Right? So, suppose we run this. And now, we do another one. Now, let's try to do a list comprehension. Now we do another one. Now let's try to do a list comprehension. W is equal to translate N for N in X. Does it do that? Take all the numbers and add three to it? Very nice. Any function that you want. Very nice. three to it very nice any function that you want very much call list comprehension and i would strongly suggest that when you are using uh plain python extensively use list translation so what will happen is when you come from some other language you will tend to use a lot of the traditional for loops etc etc when you are dealing with arrays or with less but there's no reason to the moment you see a list ask yourself can i write a more elegant syntax just using list comprehension right and so this is it now comes a thing about numpy how would you have done this in numpy numpy would have been uh y let me just use a y numpy is equal to np sqrt x this looks the numpy version of it looks, the NumPy version of it. What do you notice? Now, how many of you are impressed that you can do it like that? You don't have to do even less comprehension. So this is called a NumPy broadcast. The operation is automatically broadcast broadcast the concept in broadcast so this is a numpy or the data science specific construct but we expect we treat less as vectors so in mathematics we can take the square root of vector and it would be the square root of every component of that vector. NumPy will respect that. Do you see that guys? Is this, is this simple to understand? Can you repeat broadcast and event please? See what is X? Just to remind you what is X? It's an array of numbers. It's an array of numbers. So let me just print it out X see specifically here X is an array of integers and Y numpy would be an array of floats yeah and it doesn't matter it doesn't matter it will auto convert it to yes this is it here it is so X was this and what is why it is this so ask if you do not have to traverse the entire array what you're saying automatically multiply the square root of those numbers and provide you a new array. Yes. So it will do every element, it will apply that function. Yeah, this is fabulous. Really fabulous. Yes. And that is the power of the AI libraries and this, and which is why I say, I tell you guys that it is good to know Python know Python enough Python but you don't have to go overboard in Python because the machine learning libraries that we use are very specific to machine learning and they they are just amazing plus if now a curiosity question so you put Y numpy equal to NP square root of X yeah let's say you had an arithmetic term after that plus another array operator and the cardinality of that array is not the same as this array so let us add three to these numbers all of them or 300 that it becomes obvious even this will get broadcast any operation you do will automatically happen to every element of it do you notice that the result is every element now starts with 300 plus something and if that's another array whose cardinality is not the same as the cardinality of what happens right so the overall array will return the cardinality of x which is 10 yeah the result and so to every element you are first taking the square root and then adding 300 now if the instead of 300 if i had another let's say it's np square root of y and the cardinality of y was slightly different from x yeah so let me just say a power x 4 the fourth power of x let's say right so now let's see what happens uh i'm sorry uh you can't do np power the syntax is wrong what did i do has no attribute call power exp okay let me just do exp that would be why am i having this issue exponent is there return array must be of array type yeah so this is first let us see what type it is so yeah we have to go a little bit slow let us go a bit slow print it out and see what comes out print this this up it is not letting us do np to the power of four okay let me do it the other simple way you have x see the moment you have oh because X is not a numpy array. Did I not make it a numpy array? Yes, so one of the things you have to remember is that when you deal with numpy, try to only deal with numpy. So let's redo xx is equal to np.array of x. And then print x and then first do this thing. And then I'll show you what we mean by that. So you see that. And now let's try to do zz is equal to np.exp. Let us say we take xx3 right and then we do print three print ZZ let's see what comes out something it didn't like a broadcast it's making a broadcast complaint return area must be of type arrays must be of type this so it is array yeah maybe it doesn't like that okay i'll just do just to illustrate the point you're making i'll come and figure it out let's take the third power of it directly so now you have two arrays both of them with 10 numbers and your point was that can i brought apply broadcast to the first one right this will lead to a broadcast value the squaring of each number and can i therefore add either zz or directly xx star star three right and this will go through just fine star star 3 right and this will go through just fine previously that's what you were asking one second so i was actually trying to see if the cardinality also will match in this case the cardinality is the same yeah so let's say x has cardinality of in this case what 10 right let's say we had another array y then it will fail so I'll tell you that so Y is equal to NP dot array let us say this let us just take something 2 4, four, three, two, four, five. Now the sizes are different, isn't it? And now see what happens when you try to do this. If you have a comma there instead of dot. Oh my goodness, yeah. This is it. So when you look at this, what is it complaining? Broadcast, remember? And it will give you the message value error operands could not be broadcast together because their shapes are different one is 10 the other is three okay right so it will give you those uh those error messages so the big uh the big lesson to learn here guys is that we should use numpy as much as possible so take it as a exercise that today you will go and get introduced to numpy number is just magical and most of it is if you remember your high school algebra you know numpy so numpy API suppose I you go to the API doc of NumPy reference. What you will notice is that you almost don't have to learn anything. Let's go to numpy.org docs, manual, et cetera, arrays. So how do you deal with n-dimensional arrays, et cetera, et etc. Broadcasting is something worthwhile learning. Actually, let's look at the API. go to some basic NumPy tutorial. NumPy API, API doc, right, and NumPy documentation. Let's start from here. So here it is. You can read the documentation on the web. And you can see the API reference. So do the quick start tutorial. You'll be absolutely surprised how easy it is to pick it up. Once you have installed NumPy, you play around with the arrays, but you have to become familiar with it. See, it is easy, but it doesn't mean that it won't take time. It will eat up the better part of your day to understand this, you know, do all these very basic operations, adding arrays, multiplying arrays and things like that. And I would like to say that today, just give to that before next time we'll do functions and other things, but see more than anything else, the heart of machine learning, right, is arrays, multidimensional arrays. So you have to know NumPy and in PyTorch, you have to know tensors. If you know these two things very well, you will realize that other things come very intuitively and NumPy is as close to just writing mathematics on paper as you could be it is once you get used to the syntax right it's very very very intuitive so how do you learn the basics so i would say that a gift today tomorrow to picking up the basics of numpy see am i right to assume that numpy although we keep referring to it only in the context of arrays it can also do all the matrix calculations right absolutely absolutely it can do that all all of that all of that. Wow, that's it. It's very, very powerful. Nampai, you know, it is what took, it just made it easy to use 30, 40 years of scientific computing and all the wealth of information that had accumulated. See guys, when you write software, business software, that comes and goes. Today it's one language, tomorrow it's another. Today it's Angular, tomorrow it'll be something else, maybe React. And it will keep on moving forward. J2E came and the EJBs came and EJBs went. Some of you may remember COM, DCECOM, and whatnot, and MRC. All of these things come and go, they're transient things. But mathematics is more or less eternal. And the numerical libraries that people write, it takes many, many years to make them A, fast, and B, correct. And it shows up in many ways, actually. So for example, if you want to take the average of two numbers, intuitively you would write in your code a plus b divided by two isn't it but actually that is wrong from an environmental perspective or because it will lead to overflow if both these numbers are too big and they're close to the maximum value that that data type supports a plus b will already be an overflow and divide by two will return you a random number right so you have to know that to take the average you have to first take the difference you have to do the smaller of a a and b whichever it is let's say a is smaller a plus b minus a over two right you have to do it like that and it takes a while actually to go fix bugs sometimes these subtle bugs and this bug is very interesting it turns out that in Java's sorting algorithm they had to find that median somehow or the middle guy at one point and for almost 10 years this bug stayed in Java sorting algorithm and Java sorting algorithm is written by people who are an army of entities and some of the most rigorous people in the world, right? So that is the nature of scientific computing that when you do deep down algorithmic stuff, it takes many years to make it perfect. So those libraries, Blas and Linpack, Lapack, Atlas, they have been perfected over decades and secondly their performance is absolutely close to the bare metal performance you can ever get nothing comes close so people don't try to reinvent the wheel it's taken a long long time to build that wheel what they do is they put layers uh usability think of it as user interfaces on top of it and python in some sense is a very simple user interface because the the only sort of people who were using fortran and see well people like me you know who are deeply into scientific computing and uh it's not come out it's not sort of democratized. Most people don't learn Fortran. In fact, they believe Fortran is dead. Most people don't want to learn C these days. They start with a Python and they don't want to learn any other language. Maybe they'll learn Python and JavaScript and that is it, or Java or something like that so how do you take all that intellectual heritage and make it available that is what numpy like skip I does skip I is unpacked so I said in Python it's an interpreted language right they are the so basically for the libraries the execut executables already available when the interpretation happens yes actually when you when you install a now this thing python's uh machine learning libraries right when you do conda install numpy you'll actually see that it is installing fortran and if you look at the messages when it does the installation you will suddenly realize that it's installing fortran and so a call when you make an interpreted call a star b right x star y right let's go back to our code when you do something like uh where is it something elegant like uh i don't know uh where did i use this let's say the document, right? So this is deliberately a mistake. So let me just say broadcast mistake. Forget this. Look at this part, look at this part, right? When you do something like that, the array that you create, like for like that the array that you create like for example this array that you create it is not in python memory this array is actually sitting in the fortran and c memory ah yeah that is it and so when you multiply all it does is that it calls the C binding and says go multiplied by three. Okay. Third power of the array. Interesting. Wow. Very interesting. So basically the C, the, it's literally that C a Fortran that libraries precompile to the platform and made available as a library. Everything is there. Absolutely. Oh, and then you i use the super fast malloc and all the supervision routines like this like under the hood in fact uh because it's fortune like a lot of these things are in fortran so there is not the this you know this there is no pointers it's extremely fast it is what today we call cache conscious algorithm right the beauty of that data will be highly contiguous they will load in memory in not just the memory they will load into the cpu cache right quite often the the computations can be done in the l1 and l2 cache itself you don't even have to go to l3 cache but can imagine how billions, like literally millions of times faster the entire thing becomes. So, Asif. I mean, it's exploiting the locality of reference property, right? You know, the array is contiguous, it's just exploiting that property. Yeah, I mean, very nicely, yeah. Asif, do we have for each loops in Python? You know what I'm saying right and elements the JavaScript for each syntax is not okay say let's comprehend is the year for each okay okay so there is also something called a generator which does a lazy evaluation. So let me explain that. So for example, if you do this, let me call w lazy. And instead of square brackets, if you do translate n for n in x, right? And so let me put it here, print W. So you can see that with list comprehension here, with list comprehension, list comprehension, you get Eagle evaluation. Eagle evaluation is a fancy word of saying you get exactly what happens is exactly what you think happens. Namely, all the values of w array are computed but when you do but with uh these things are called funny things these are called with generators it is lazy evaluation now why would that be useful? Let's see, print W lazy and C. See, when you notice that, I printed W, it actually produced the numbers. But if I just change the square bracket to curvy bracket, and I try to print W lazy, it doesn't do that. It actually gives me a generator. Generator says I'll evaluate it if you ask me to evaluate it. So if you iterate over me me then I will do that so suppose you say for W lazy the reason is it gives you optimization because you know if you you can give a formula and you can say suppose you want to do it only for first 10 elements or something like that then you don't want to compute the entire thing but if you do that it will still produce the same result right because then it will lazily evaluate it right but the beauty of this is suppose you do this why is this elegant? Suppose you did this for i in range of three. So let's say that, imagine that three is a huge number. So suppose that you do a print num. Then what happens is the rest of the translations are not even printed. So print only, compute only, So print only compute only on demand. Right? And so what happens is here, these three, oh, what did I do? Print for I in number. So I don't think you can index into W, but we'll try it. I think this will throw up for I in W. I think it will throw up. No, it did. It computed it. So what happens is when you ask for three elements, it will only compute the three elements. So what's the advantage of this? Can you identify the advantage of using generators? Nice. If the function takes a lot of time to save it. Yes. So those values that you don't refer are never computed and it's a massive saving. So generators, I would say is one thing that I find most python programmers don't use but you should ask yourself is a generator a better thing to use here it's one of the best practices that more people should adopt using generators so ask if in javascript there is a concept called generator functions too but in that case the generator function can return multiple values and use you first get the first value said next and then gives you the next value it commutes the next part of that method and then goes on like that I don't think I don't think they mean the same here but yeah here it is an item you can do that you have to put a iterator over it the moment you put a iterator generator you get exactly the same effect okay i think they're trying to create in that case i i understand why they did it in javascript i think they are trying to create like a thread concept in javascript so if you have a thread concept, you have your fork few threads and you want to get it information from there and then move on and then generate a functions is useful. I yeah, maybe. Yeah. I don't know the threading or the underlying architecture of JavaScript. I just know JavaScript as a language and on the surface, the syntax of it, but it's the link things I don't understand. So I can't comment on that. Okay, thank you. Asma N. Bhasin. Sorry. Asma N. Bhasin. Thank you. So what does the keywords or something that is showing that it is a generator? Can you explain this in fact? Yeah, this is it. When you print it out, do you see it says that it's a generator object? Try when you print W lazy, you don't get anything. You just get the word generator object. So W lazy is a variable, right? W lazy is a variable and that point to a generator. I think I see Harini's question is around the square brackets versus the curved brackets. Yes. Square bracket is generated in array and the other one is a generator. Yeah. bracket is generated an array in the other one it is a generator yeah so if you use this curvy bracket harini you're saying don't make it into lazy evaluation mode in other words produce a generator that is it that's the only difference and it's quite elegant actually how much performance sometimes you can gain simply by making this little change go from square bracket to enlist comprehension to a curvy bracket while doing comprehension and you end up with a generator. You have multiple cores on your computer. How do you make something like NumPy use multiple cores? What I see here is every time it executes it only uses one CPU oh how do you do parallel computing with this see there are there ways of doing that let's not get into that but the simple answer is yes so first of all right numpy is lightning when you look at libraries like numpy under the covers, they are very smart. You don't know how it is doing. It is doing it in a very smart way under the covers and there are ways to give it very explicit hints. Something that we just add as a declarative somewhere and then it starts using all the code. Exactly. If you code, you just declare this and then that is picked up. So there's a lot here, DASC and other things. So we'll come to that. See, here's the thing. Let's begin to learn to work before we run, but we'll come to that. All of those lovely things are there. See, scientific computing libraries are just amazing. Pick up enough Python that you can enter into the scientific computing libraries. And after that, the AI libraries. And AI libraries are like absolutely the very next level compared to normal Python, because they are leveraging not the syntax of Python so much. They are leveraging the underlying Fortran and C, which are absolutely as fast as it can be. You're living 30-40 years of work there, 40-50 years of work. But I was just trying to connect the dots. I was wondering like that's more of a distributed system design problem, right? Like the problem exists whether you like do NumPy or standard Python, right read that like basically the CPU that process CPU coastal exists that problem still will exist right I thought it's independent or is that something no it basic more basic you do it in Python it's a interpreted language every line of code is converted to machine code on the fly when you run it. Any interpreted language will be gazillions of times slower, I mean, in a very colloquial way speaking, than fully optimized binaries like that produced by optimized Fortran or optimized C. That is absolutely. I said, what I was thinking was like the problem of like single versus multiple core, that problem will exist in both the scenarios, whether they use standard Python libraries or use NumPy. That's a different problem to solve. Correct. That is a different problem to solve. But having said that, you have to give the hints to the NumPy that you have the access to all of that and it will use it. Which core and core affinity, I guess like core affinity and all those, that's what you're talking about, right? Like all those smart. Yeah, you can do that. You specify the number of, you don't even have to give affinity to a specific course, but just declare that these are the course and you run with it and see what happens is that we are talking of numpy fact of the matter is numpy with all its power has one tremendous limitation it runs in CPU memory CPU is a general purpose thing it wasn't designed for floating-point operation the other thing is numpy is basic unit float is a 64 byte float, right? Okay. Machine learning and gradient descent, actually, you don't want that high degree of precision. You want to actually use 16 byte precision, very low precision floating point operations because your numbers are between zero and one near the ingredient 32 is is the standard 16 sometimes gives you amazing results without loss of accuracy and it runs almost 10 times faster so what happens is that you want to run it first of all on actual tensor dedicated tensor processing units so when you Nvidia's card and Google set TPU in the cloud they have dedicated tensor operators they are meant for matrix multiplication and differentiation literally imagine see Intel is written on the Intel 32 instruction set right I a 32 instruction set isn't it and now they have expanded it to IA 60, AMD 64 and all of that. But imagine an instruction set that is designed from the ground up to only do matrix multiplication and differentiation. That is it. A very tight instruction set designed at that level. So you can imagine how blazingly fast it will be. That is why there is a, there was a, maybe I show you a demo. It's an old, old demo that NVIDIA did as a marketing stunt, but it sort of proves the point. I'm not being a shell or a mouthpiece of NVIDIA because this is generally true of all tensor processing units. So all the demo they did once, NVIDIA, Mona, Lisa demo. Okay, so guys, I hope you can hear my sound. I'll make sure that you can share computer sound. But just watch this for a moment. Demoo GPU. We can't hear the sound. We can we can't, nor can I. So let me go to the one where the sound is more clear. We'll do this one. Oh, sorry. And he's going to paint a picture for you guys. Let me start from the beginning. All right. I introduced you Leonardo and he's going to paint a picture for you guys in the way that a CPU might do it as a series of discrete actions perform sequentially one after the other in three two one Ladies and gentlemen. Leonardo. 2.0. When we hit this trigger on this thing, 2,100 gallons of air goes through these accumulators, out these valves, into all 1,100 of these tubes, into these tubes in which the bottom of is a paintball. Each of those paintballs will fly across seven feet of space and in 80 milliseconds reach its target, hopefully. So guys, before I do that, you see that this entire system is a giant array, right? Two-dimensional array, matrix system. Yep. The matrix multiplication means all elements act at the same time and see what happens when compared to the CPU. When it's all said and done, it's going to paint the Mona Lisa. GPU painting demonstration. eight, seven, six, five, four, three, two, one. Ladies and gentlemen, science class is now over. Thank you. Thank you. So I hope guys you with this video you see why you should use the scientific computing libraries. NumPy is this when you're running on when you use PyTor right the tensors and you use tpus your performance is this so if you guys have a laptop that doesn't have a discrete graphic card with a qr support you are doing it like the first intel cpu dot dot dot dot you know sequential computing whereas when you do it with the with this pi torch you see what happens. You're just looking at a dimensionally more powerful machine. And that is what is used for AI these days. Make sense guys? Yep. That is it. And so today we have been one and a half hours. I'll stop here guys. So what is the homework for this? Go learn NumPy. It's very easy. It is as close to mathematics start with everything. Start with the basics, right? The beginner's tutorial, you know, the quick start tutorial, beginner's tutorial. There are many tutorials here. And gradually you'll realize that it is, you can't think of a library or an API design more simply for mathematics, for basic arithmetic, right? All right, guys, and so with with those I'll stop.